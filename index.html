<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title></title>
  </head>
  <body>
    <header>
      <h1>This is my test page for Java!</h1>
      <h2>This is my h2</h2>
    </header>
    <main>
      <button>Start machine</button>
      <p id="sunshine">The machine is stopped.</p>

    </main>
    <script>
      const btn = document.querySelector("button");
      const txt = document.querySelector("p");

      btn.addEventListener("click", updateBtn);

      function updateBtn() {
        if (btn.textContent === "Start machine") {
          btn.textContent = "Stop machine";
          txt.textContent = "The machine has started!";
        } else {
          btn.textContent = "Start machine";
          txt.textContent = "The machine is stopped.";
        }
      }
let a = 10;
console.log(a); //console log will appear in dev tools 

//string is java is always surrounded by quotes. 
//"are okay" 'are okay' `are okay`
//backticks `` allow us to embed variables and expressions into a string with ${...}
let name = "John";

//embed a variable
alert( `Hello, ${name}`); // you get alerted "Hello, John"

//embed an expression
alert(`the result is ${1+2}`); //you get alerted "the result is 3"


//Boolean (logical type) has only 2 values: True or False
//these are used as Yes/No values often. (Yes=True//No=False)
let nameFieldChecked = true;//means Yes, the name field is checked
let ageFieldChecked = false;//means No, the age field is not checked

//Boolean can answer comparisons as well
let isGreater = 4 > 1;
alert(isGreater);//alerted "true"

//"Null" is a special value that represents "nothing" "empty" or "value unknown"
let age = null;//means that the age is unknown



//"undefined" works just like null. The meaning of "undefined" is "value is not assigned"
//if a variable is declared but not assigned then its value is "undefined"
let age;

alert(age);//shows "undefined"
//you can technically assign "undefined" to a variable
let age = 100;
age = undefined;

alert(age); //"undefined"
//THIS IS NOT RECOMMENDED. NULL IS USED TO ASSIGN "EMPTY" OR "UNKNOWN" VALUES
//UNDEFINED IS RESERVED AS A DEFAULT INITIAL VALUE FOR UNASSIGNED THINGS




object //is SPECIAL
//all other types are considered primitive because they can only hold a single thing(string or number or whatver)
object //is used to store collections of data and more complex entities. 
//more to come on "object" later
symbol //is used to create unique indentifiers for objects.
//also more on that later whe nwe get into object more.


typeof //will return the actual type of the operand
typeof undefined // will spit out "undefined"

typeof 0 // will return "number"
typeof true //will return "boolean"
typeof "foo" //will return "string"
typeof alert //will reutrn "function"
typeof(alert)//works the same and will return "function"

// typeof x    IS MUCH MORE COMMON AND RECOMMENDED


//!!!!below is a Summary!!!!

//THERE ARE 8 BASIC DATA TYPES IN JAVA
// 7 PRIMITIVE TYPES
Number //for both floating and integers
BigInt // for integer numbers of arbitrary length
String //for strings(strings can have 0 or more characters, there is no separate single character type)
Boolean // for True/False
null // for UNKNOWN vlaues..a standalone type that has a single value "null"
undefined // for UNASSIGNED value..a standalone type that has a single value "undefined"
symbol //for unique identifiers 
//and one non-primitive type
object // for more complex data structures


typeof //operator shows which type is stored inside a variable



//deeper dive on strings
const goodString = "Use quotes to make strings";


const badString = no quotes;
const badString2 = 'single sided quote;
const badString3 = anything other than quotes really';
//browser will let you know what error(missing; before statement) or (unterminated string literal) 
//CANNOT USE TWO DIFFERENT CHARACTERS TO START/END A STRING
//IF YOU START WITH " THEN FINSIH WITH "
const badQuotes = 'This would not work";


//Remember that backticks `are used to embed java in them`
const name = "Chris";
const greeting = `Hello, ${name}`;
console.log(greeting); //will output "Hello, Chris"
//You can use the same technique to join 2 variables together.
const one = "Hello, ";
const two = "how are you?";
const joined = `${one}${two}`
console.log(joined); //outputs "Hello, how are you?"




//below is about concatenation in context




//the fucntion "prompt" will ask the user a question via a popup dialog box

//html--<button>Press me</button>
//html--<div id="greeting"></div>
const button = document.querySelector("button");

function greet() {
  const name = prompt("What is your name?");
  const greeting = document.querySelector("#greeting");
  greeting.textContent = `Hello ${name}, nice to see you!`;
}

button.addEventListener("click", greet);

//the + operator can concatenate normal string
const greeting = "helloo"
const name = "Chris"
console.log(greeting + ", " + name);//outputs "Hello, Chris"
//note the quotes in the middle are standing for a comma and a space between greeting and name


//expressions can be used inside strings just likle variables
const song = "Fight the Youth"
const score = 9;
const highestScore = 10;
const output = `I like the song ${song}. I gave it a score of ${(score/highestScore) * 100}%.`;
console.log(output);//will return "I like the song Fight The Youth. I gave it a score of 90%."




//MULTILINE STRINGS
//since Template literals(`backticks`) respect line breaks in source code, use mutliline strings
const newline = `One day you finally knew 
what you had to do, and began,`;
console.log(newline);
//will return WITH the line break. !!!HOLD 'SHIFT' AND HIT 'ENTER' TO LINE BREAK WITHOUT EXECUTING
// notice the backticks before. now lets use quotes
const newline = "One day you finally knew\nwhat you had to do, and began,";
console.log(newline);
//should output the same line break format as above. the \n represents a linebreak so you also do not need a space.



//you can also include quotes in your strings
//but since we use quotes to start strings
const badQuotes1 = "She said "I think so!"";//does NOT work
//comon option is to use the other characters (""   ''  ``)
constgoodQuote1 = 'She said "I think so!"';
const goodQuote2 = `She said "I'm not going in there!"`;

//another option is 'escaping' the quotation marks
//'escaping' means that we do something to them to make sure they are recognized as text, not part of the code.
//we do this by putting a BACKSLASH just before the character
const bigmouth = 'I\'ve got no right to take the throne...';
console.log(bigmouth)
//should output: "I've got no right to take the throne..."
//YOU CAN ALSO USE DIFFERENT CHARCTERS LIKE QUOTES OUTSIDE OF SINGLE QUOTES
const bigmouth = "I'VE GOT NO TIME FOR THIS"


//NUMBERS VS STRINGS

//when we try to concatenate strings and numbers they are converted to 2strings put together
const name = "Front ";
const number = 242;
console.log(name + number);
//will return "Front 242"
//note the space after front to get the space in the output

//you can convert any string into a number or number into a string using 1 of 2 functions
Number() 
String()
//example
const myString = "123";
const myNum = Number(myString);
console.log(typeof myNum);
//should output "number" with typeof function showing you TYPE it is
//OPPOSITE
const myNum2 = 123;
const myString2 = String(myNum2);
console.log(typeof myString2);
//should output string for same function reason as above in line 224

//more string methods!!! 
https://www.w3schools.com/js/js_string_methods.asp


//the 'length' property returns the length os a string
let text = "abcdefghijklmnopqrstuvwxyz"
let length = text.length;
console.log(length)
//should output "26"


//there are 3 methods to EXTRACTING string parts
slice(start, end) 
substring(start, end)
substr(start, length)

//SLICE extracts a part of a string and returns the extracted part in a new string
//this needs two parameters: start position and end position.(end not included)
let text = "Apple, Banana, Kiwi";
let part = text.slice(7,13);
console.log(part);
//will return "Banana"
//note that slice counts the first position as 0! 2nd position as 1!

//omitting the second parameter will slice out the rest of the string
let text = "Apple, Banana, Kiwi";
let part = text.slice(7);
console.log(part)
//will return "Banana"

let text = "Apple, Banana, Kiwi";
let part = text.slice(-12);
//using a negative COUNTS BACKWARD from the end of the string 
//output above should be "Banana, Kiwi"

let text = "Apple, Banana, Kiwi";
let part = text.slice(-12, -6);
//two negative act normally as this would slice out position -12 to position -6
//output will return "Banana"







//SUBSTRING() is similar to slice. 
//Difference is that start and end values less than 0 are treated as 0 in substring()
let str = "Apple, Banana, Kiwi";
let part = str.substring(7,13);
console.log(part);
//will return "Banana"
//substring extracts part of the string and returns it as a new string

//ommiting the second parameter causes the same action to happen (rest of string will be sliced out and returned)







//SUBSTR is another method and is very similar to slice

//
//the difference is that the second parameter specifies the LENGTH of the extracted part
let test = "Apple, Banana, Kiwi";
let part = test.substr(7,6);
console.log(part); 
//will return "Banana"
//It took the 6 characters from the 7th position(B) to get Banana


//much like slice, omitting the 2nd parameter slices out the rest of the string.
let str = "Apple, Banana, Kiwi";
let part = str.substr(7);
//will return "Banana, Kiwi"

//and again, much like slice, if the parameter is negative then it counts from the end of the string.
let str = "Apple, Banana, Kiwi"
let part = str.substr(-4);
console.log(part);
//will return "Kiwi"






//REPLACING STRING CONTENT
replace() //is a method that replaces a specified value with another value in a string

let text = "Please visit microsoft and microsoft!"
let newText = text.replace("microsoft", "w3Schools");
//shoudl return "Please visit w3Schools and microsoft!"
//look at notes below as to why it did not change both

//NOTE: the replace() method does not change the string it is called on
//NOTE: the replace() method returns a new string
//NOTE: the replace() method replaces ONLY THE FIRST match
//default: is set to only replace the FIRST MATCH
//default: replace() method is case sensitive[writing 'MICROSOFT' would not work]



//TO REPLACE ALL MATCHES, use a regular expression with a /g flag (global)
let text = "Please visit Microsoft and Microsoft!";
let newText = text.replace(/Microsoft/g, "W3Schools");
//will return "Please visit w3Schools and w3Schools"


//you can replace case insensitive using a 'regular expression' with an /i flag (insensitive)
let text = "Please visit Microsoft!";
let newText = text.replace(/MICROSOFT/i, "w3Schools");
//will return "Please visit w3Schools"


//REGULAR EXPRESSIONS are written without quotes but we will learn more about them later on.



//REPLACEALL() method
let text = "I love cats. Cats are so cool and fun. Cats are soft"
text = text.replaceAll("cats","dogs");
text = text.replaceAll("Cats","Dogs");
//will return "I love dogs. Dogs are so cool and fun. Dogs are soft"
//note I did it for both capitalized versions and lowercase versions

//replaceAll() method allows you to specify a regular expression instead of a string to be replaced
//if the parameter is a regular expression, the global flag(g) must be set. otherwise:ERROR
text = text.replaceAll(/Cats/g,"Dogs")
text = text.replaceAll(/cats/g,"dogs")
//NOTE: replaceAll() does NOT work on Internet Explorer.






//Java string to uppercase or lower case
toUpperCase()
toLowerCase()

let text1 = "Hello World!";
let text2 = text1.toUpperCase();
console.log(text2)
//will return "HELLO WORLD!"

let text1 = "Good Day Here Mate!";
let text2 = text1.toLowerCase();
console.log(text2);
//will return "good day here mate"







//JAVA STRING CONCAT()
concat() //joins two or more strings

let text1 = "Hello";
let text2 = "world!";
let text3 = text1.concat(" ", text2)
//will return "Hello World!"
//note, again, the space inbetween the quotes 

//concat() can be used instead of the + operator
text = "Hello" + " " + "World!"; //note the quotes around each operand
text = "Hello".concat(" ", "World!");
console.log(text)
//both will return "Hello World!"

//NOTE: ALL STRING METHODS RETURN A NEW STRING. THEY DO NOT MODIFY THE ORIGINAL STRING
//Strings are immutable: Strings cannot be changed, only replaced.





//JAVA STRING TRIM()
trim() //method removes whitespace from both sides of a string

let text1 = "         Hello World!      ";
let text2 = text1.trim();
console.log(text2);
//will return "Hello World";
console.log(text1);
//will return "         Hello World!      "

trimStart() //method works like trim(), but removes whitespaces only from the start of the string
let text1 = "       Hello World!       ";
let text2 = text1.trimStart();
console.log(text2)
//will return "Hello World           "

trimEnd() // works just the opposite and removes whitespaces from the end of the string

let text1 = "    Hello World!       ";
let text2 = text1.trimEnd();
console.log(text2)
//will return "      Hello World!"






//JAVA STRING PADDING
padStart()
padEnd()
//were both added to support padding at the beginning and at the end of a string
//this pads the string with another string(multiple times) until it reaches a given length. 

//example: pad a string with "0" until it reaches the length 4:
let text = "5";
let padded = text.padStart(4,"0");
console.log(padded);
//will return "0005"

//pad a string with "x" until it reaches the length 4:
let text = "5";
let padded = text.padStart(4,"x");
console.log(padded);
//will return "xxx5"


//padStart() and padEnd() are string methods. meaning to pad a number, you must convert that number to a string first
let numb = 5
let text = numb.toString();
let padded = text.padStart(4,"0");
console.log(padded);
//will return "0005"

//padEnd() is not supported in Internet Explorer





// Extracting String Characters
//3 methods for extracting string characters:
charAt 
charCodeAt
Property access []


charAt // method returns the character at a specified index (position) in a string:
let text = "Hello World!";
let char = text.charAt(0);
console.log(char);
//will return "H"
//charAt (character at) [remember that the first position is 0]


charCodeAt() //method returns the unicode of the character at a specified index in a string
//the method returns a UTF-16 code (an integer between 0 and 65535)
let text = "Hello World!";
let char = text.charCodeAt(0);
console.log(char);
//will return "72"
//more on unicode in the doc below:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String



[...] // allows property access [] on strings.

let text = "Hello World!";
let char = text[0];
console.log(char)
//will return "H"
//meaning the first character (0)
//NOTE: PROPERTY ACCESS IS A LITTLE UNPREDICTABLE
//- it makes strings look like arrays (they are not)
//- if no chartacter is found, [] returns undefined, (while charAt returns an empty string)
// - it is read only. str[0]="A" gives no error (but does not work)
let text = "HELLO WORLD";
text[0] = "A";
//gives no error but does not work







//CONVERTING A STRING TO AN ARRAY
//like converting numbers, if you want to work with strings as an array, you must convert it to an array

//JAVA STRING SPLIT() METHOD
split() //can be used to convert strings to arrays

text.split(",") //means to Split on commas
text.split(" ") //means to Split on spaces
text.split("|") //means to Split on pipe


let text = "a,b,c,d,e,f";
const myArray = text.split(",");
console.log(myArray[0]);
//returns "a"
//NOTE that the [] after myArray specifies which character
//console.log(myArray); would return "a b c d e f" 


//REMEMBER! JavaScript treats strings as objects when executing methods and properties.


charAt()	//Returns the character at a specified index (position)
charCodeAt()	//Returns the Unicode of the character at a specified index
concat()	//Returns two or more joined strings
constructor	//Returns the string's constructor function
endsWith()	//Returns if a string ends with a specified value
fromCharCode()	//Returns Unicode values as characters
includes()	//Returns if a string contains a specified value
indexOf()	//Returns the index (position) of the first occurrence of a value in a string
lastIndexOf()	//Returns the index (position) of the last occurrence of a value in a string
length	//Returns the length of a string
localeCompare()	//Compares two strings in the current locale
match()	//Searches a string for a value, or a regular expression, and returns the matches
prototype	//Allows you to add properties and methods to an object
repeat()	//Returns a new string with a number of copies of a string
replace()	//Searches a string for a pattern, and returns a string where the first match is replaced
replaceAll()	//Searches a string for a pattern and returns a new string where all matches are replaced
search()	//Searches a string for a value, or regular expression, and returns the index (position) of the match
slice()	//Extracts a part of a string and returns a new string
split()	//Splits a string into an array of substrings
startsWith()	//Checks whether a string begins with specified characters
substr()	//Extracts a number of characters from a string, from a start index (position)
substring()	//Extracts characters from a string, between two specified indices (positions)
toLocaleLowerCase()	//Returns a string converted to lowercase letters, using the host's locale
toLocaleUpperCase()	//Returns a string converted to uppercase letters, using the host's locale
toLowerCase()	//Returns a string converted to lowercase letters
toString()	//Returns a string or a string object as a string
toUpperCase()	//Returns a string converted to uppercase letters
trim()	//Returns a string with removed whitespaces
trimEnd()	//Returns a string with removed whitespaces from the end
trimStart()	//Returns a string with removed whitespaces from the start
valueOf()	//Returns the primitive value of a string or a string object



Complete string reference guide:

https://www.w3schools.com/jsref/jsref_obj_string.asp

use this to test yourself with exercises:

https://www.w3schools.com/js/exercise_js.asp?filename=exercise_js_string_methods1










//COMPARISONS
//we know many comparison operators in math:    greater than, less than, equals to
//they are written as the following in Java:
a > b, a < b
a >= b, a <= b //"greater than or equals to", "less than or equals to"
a == b //NOTE  THE DOUBLE EQUALS MEANS THE EQUALITY TEST/ NOT AN ASSIGNMENT LIKE SINLGE =
a != b //means "NOT equals to" in Java

//BY THE END, YOU SHOULD FIND A GOOD RECIPE TO AVOID "JAVASCRIPT QUIRKS"-RELATED ISSUES

//COMPARISON operators return a boolean value.(see line 47 for boolean)
alert(2>1);
//will return "true"
alert(2==1);
//will return "false"
alert(2!=1);
//will return "true"


//a COMPARISON result can be assigned to a varibale, just like any value.
let result = 5>4;
alert(result);
//will return "true"





////STRING COMPARSION 
//To see whether a string is greater than another, Java uses the so-called "dictionary" or "lexicographical" order
//in other words strings are compared letter-by-letter
EXAMPLE1: alert ( 'Z' > 'A' );
//will return "true"
EXAMPLE 2: alert( 'Glow' > 'Glee' );
//will return "true"
 EXAMPLE 3: alert( 'Bee' > 'Be' );
//will return "true"

//ASKING WHY?^?^?
//The algorithm to compare two strings is simple:
// 1- Compare the first character of both strings.
// 2- If the first character from the first string is greater (or less) than the other string’s, then the first string is greater (or less) than the second. We’re done.
// 3- Otherwise, if both strings’ first characters are the same, compare the second characters the same way.
// 4- Repeat until the end of either string.
// 5- If both strings end at the same length, then they are equal. Otherwise, the longer string is greater.
EXAMPLE2: G is the same as G.
l is the same as l.
o is greater than e. Stop here. The first string is greater.



//  NOTE : ANY VALUE THAT IS NOT 'FALSE', 'UNDEFINED', 'NULL', '0', 'NaN', or an empty string ("") reutrns true!




//When comparing values of different types, Java converts them to numbers.
alert( '2' > 1); 
//will return "true". because string becomes a number in java^^^^
alert( '01' == 1 );
//will return "true". becuase the string'01' becomes a number 1.

//BOOLEAN VALUES BECOME NUMBERS AS WELL. true is equal to 1. false is equal to 0
alert( true==1 );
//will return "true"
alert( false == 0);
//will return "true"





//STRICT EQUALITY
//a regular equality check (==) has a problem. It CANNOT differentiate 0 from false.
alert( 0 == false);
//will return "true"
alert( '' == false);
//will return "true"
//NOTE: this happens becuase operands are converted to numbers by the ==. 
//An empty string, just like "false", becomes a zero.


//to differentiate 0 from false. use a STRICT EQUALITY(===) operator.
// === checks the equality without type conversion.
//in other words, if a and b are of different types, then a === b immediately returns "false" without an attempt to convert them
alert( 0 === false );
//will return "false". because the types are different.


//NOTE: THERE IS A 'STRICT NON-EQUALITY' OPERATOR. !== 
// The 'strict non-equality' makes it obvious whats going on, leaving less room for errors.





//COMPARISONS with null and undefined;
alert( null === undefined );
//will return "false". because they are two different types.
alert( null == undefined );
//will return "true". becuase these two have a "sweet couple" relationship
//NOTE:they equal each other in the sense of == but not any other value.

//for maths and other comparisons (<, >, <=, >=), null12 and undefined are converted to numbers.
//NULL becomes 0. UNDEFINED becomes NaN(not a number)0

alert( null > 0 );  
//will return "false"
alert( null == 0 ); 
// will return "false"
alert( null >= 0 ); 
// will return "true"

//Mathematically, that’s strange. The last result states that "null is greater than or equal to zero", so in one of the comparisons above it must be true, but they are both false.
//The reason is that an equality check == and comparisons > < >= <= work differently. Comparisons convert null to a number, treating it as 0. That’s why (3) null >= 0 is true and (1) null > 0 is false.
//On the other hand, the equality check == for undefined and null is defined such that, without any conversions, they equal each other and don’t equal anything else. That’s why (2) null == 0 is false.





//AN INCOMPARABLE UNDEFINED
//the value 'undefined' shouldn't be compared to other values:
alert( undefined > 0 ); 
// will return "false"
alert( undefined < 0 ); 
// will return "false" 
alert( undefined == 0 ); 
// will return "false" 

//NOTE: 1st and 2nd example are false becuase undefined gets converted to NaN(which returns false for all comparisons)
//NOTE: 3rd example equality check returns false because 'undefined' only equals 'null', 'defined', and no other value.





//THESE STRANGE EXAMPLES WILL COME UP ENOUGH TO BECOME FAMILIAR OVER TIME. USE THESE TO AVOID PROBLEMS WITH THEM:
// 
//Treat any comparison with undefined/null except the strict equality (===) with exceptional care.
//Don’t use comparisons >=, >, <, <= with a variable which may be null/undefined, unless you’re really sure of what you’re doing. If a variable can have these values, check for them separately.
















//!CONDITIONAL STATEMENTS!//
////////////////////////////
if
else
else if
switch
//are the 4 conditional statements.
//conditional statements perform different actions for different decisions when you write code.
if //is used to specify a block of code to be executed, if a specified condition is true.
else //is used to specify a block of code to be executed, if the same condition is false.
else if //is used to specify a new condition to test, if the first condition is false.
switch //is used to specify many alternative blocks of code to be executed.




//Use 'if' statements to specify a block of Java to be executed uf the condition is true
if(condition) {
  //input block of code to be executed if true
}
//NOTE: that 'if' is lowercase. capital letters 'IF' will result in error
//ex) making a 'good day' greeting if the hour is less than 18:00:
if (hour < 18) {
  greeting = "Good day";
}
//note that 'hour' must be defined first (or whatever you're including in the condition)




//use the 'else' statement to specify a block of code to be executred if the condition is false. 
if(condition) {
  //block to be executed if true
} else {
  //block of code to be executed if the condition is false
}
///////
if(hour<18) {
  greeting = "Good Day!"
} else {
  greeting = "Good Evening!"
}
//result now has 2 options to choose from with else meaning "if hour<18 is false"





//use the 'else if' statement to specify a new condition if the first condition is false
if(condition1) {
  //block to be executed is true
} else if(condition2) {
  //block of code to be executed if the 'condition1' is false and 'condition2' is true
} else {
  //block to be executed if condition 1 AND 2 are false
}
/////////////
if (time < 10) {
  greeting = "Good Morning!"
} else if (time < 20) {
  greeting = "Good Day!"
} else {
  greeting {
    greeting = "Good Evening!";
}
//result will depend on the time of day you look at but you can see multiple conditions being looked at.











///////////LOGICAL OPERATORS(there are 4 logical operators in Java)
|| (OR) (lines 833-899)
&& (AND) (lines 907-962)
! (NOT) (line 971-1000)
?? (Nullish Coalescing)
//Although they are called “logical”, they can be applied to values of any type, not only boolean. Their result can also be of any type.




//the OR operator is represented with two vertical line symbols:
result = a || b;

//Java makes the || a little trickier and more powerful than classic programming
//there are four possible logical combos:
alert( true || true);  //true
alert( flase || true);  //true
alert ( true || false );  //true
alert( false || false);  //false
//the result is always true except for the case when both operands are false
//if an operand is not a boolean, it is converted to one for the evaluation
//remember that 1=true and 0=false
if (1 || 0) {  //this works just like 'if (true||false)'
  alert( 'the truth!')
} //this should alert your screen "the truth!"

//NOTE: || (or) is used inside of an 'if' statement to test if any of the given conditions is true.
let hour = 9;

if (hour < 10 || hour > 18) {
  alert('the office is closed');
} // translation:  if the hour is less than 10(1000) OR the hour is greater than 18(1800)

//we can pass more conditions also
let hour = 12;
let isWeekend = true;

if (hour < 10 || hour > 18 || isWeekend) {
  alert('The Office is closed.'); 
}
// ||(or) find the first truthy value
result = value1 || value2 || value3;
// the ||(or) opertor does the following:
//evaluates operands from left to right
//for each operand, converts it to boolean, if the result is 'true', stops and returns the original value of that operand 
//if all operands have been evaluated (were all false), it will return the last operand.
//NOTE: a value is returned in its original form without the conversion.

//      A CHAIN OF || WILL RETURN THE FIRST TRUTHY VALUE. OR THE LAST VALUE IF NO TRUTHY VALUES ARE FOUND. 
alert( 1 || 0);
 // will return '1' (1 is truthy)
alert( null || 1);
//will return '1' becuase 1 is the first truthy value
alert( null || 0 || 1);
//will return '1', becuase 1 is the first truthy value
alert( undefined || null || 0); 
// will return 0, because it reads left to right and all were false, returning 0(the last value)

//THIS WILL LEAD TO INTERESTING USAGE
//    1) GETTING THE FIRST TRUTHY VALUE FROM A LIST OF VARIABLES OR EXPRESSIONS
let firstName = "";
let lastName = "";
let nickName = "SuperCoder";

alert( firstName || lastName || nickName || "Anonymous");
// will return "SuperCoder" . but if all variables were falsy, then "Anonymous" would be returned

//      2) SHORT CIRCUIT EVALUATION
// the || operator is the so-called "short-circuit" evaluation
// This means that || processes its arguments until the first truthy value is reached, and then the value is returned immediately, without even touching the other argument
// This becomes important when the operand isn't just a value, but is an expression with a side effect(variable assignment or function call)

true || alert("not printed");
false || alert("printed");
//only the second message would be alerted
// WHY? in the first line, the || stops evaluating upon seeing true, so the alert is not run
// people use this feature to execute commands only if the condition on the left part is falsy







/////// The && (AND) operator represented by two ampersands. &&
result = a && b;
//in classical programming, &&(AND) returns 'true' if both operands are truthy and 'false' otherwise
alert( true && true);
// will return 'true'
alert( false && true);
//will return 'false'
alert( true && false);
//will return 'false'
alert( false && false);
//will return 'false';
//NOTE: BOTH side must be truthy in order to return 'true'

//example using an 'if' statement

let hour = 12;
let minute = 30;

if (hour == 12 && minute == 30) {
  alert('The time is 12:30');
} // this will alert the screen 'The time is 12:30'

//just like with ||(OR), any value is allowed as an operand of &&(AND)
if (1 && 0) { //<<<<this is evaluated as 'true and false'
  alert("won't work, because the result is falsy")
}

// NOTE!!!: &&(AND) find the first falsy value
result = value1 && value2 && value3;
// NOTE: THE &&(AND) OPERATOR DOES THE FOLLOWING:
// Evaluates from left to right
// for each operand, converts it to a boolean. if the result is 'false' then it stops and returns the original value of the operand
// if all operands have been evaluated (were all truthy), it returns the last operand

// IN OTHER WORDS!!!   &&(AND) RETURNS THE FIRST FALSY VALUE OR THE LAST VALUE (IF NONE WERE FOUND)

//if the first operand is truthy. then &&(AND) will return the second operand:
alert( 1 && 0); //will return '0'
alert ( 1 && 5);// will return '5'

//if the first operand if falsy, then &&(AND) returns it and ignores the second
alert( null && 5); // will return 'null'
alert(0 && "no matter what"); //will return '0' / because the first value is falsy

// GOOD TO NOTE THAT THE PRECEDENCE OF &&(AND) IS HIGHER THAN ||(OR)
// so the code a && b || c && d is just like saying (a && b) || (c && d)

//DO NOT REPLACE 'if' WITH || or &&
let x = 1;
(x > 0) && alert('greater than zero');
// the action on the right side of the && only gets executed if the evaluations reaches it (only if x>0)
//the above is basically an analogue for:
let x = 1;
if (x > 0) alert('greater than zero');
// Although the variat with && appears shorter, 'if' is more obvious and more readable
//RECOMMENDED THAT WE USE CONTRUCT FOR THEIR PURPOSE (IF WHEN YOU WANT IF...&& IF YOU WANT AND)








/////////////The !(NOT) operator is represented with a exclamation sign!
result = !value;
//The operator accepts a single arguement and does the following:
// 1) converts the operand to boolean type.
// 2) returns the inverse value
alert( !true ); // will return 'false'
alert ( !0 ); //will return 'true'

// NOTE: a double not, !!, is sometimes used for converting a value to boolean type.
alert( !!"non-empty string"); //will return 'true'
alert( !!null); //will return 'false'. becuase the boolean value of null is returned

// The first NOT ! converts the value to boolean and returns the inverse
// The second NOT ! inverses it again. In the end, we have a plain vlaue-to-boolean conversion.

// There is a more verbose way to do the same thing. Like a built-in boolean function.
alert( Boolean("non-empty string")); // will return 'true'
alert(Boolean(null)); // will return 'false'

//The precenedence of !(NOT) is the highest of all logical operators, so it is ALWAYS executed first. before &&, before ||


//example problem: write an 'if' condition to check that 'age' is between 14 and 90 inclusively 
if ( age >= 14 && age <= 90 )
//inclusively means that age can reach the edges 14 or 90. hence the <= >=


//ex problem: write an 'if' condition to check that age is NOT between 14 and 90.
if (! (age 14 && age > 90));
if (age <14 || age > 90);


//ex problem: write a code which asks for login with 'prompt'
//visitor will enter "admin", then 'prompt' for a password
//if the input is an empty line or 'Esc'-show  "cancelled", if its another string- show "i dont know you"
//password is checked as follows: 
// - if it equals "TheMaster", then show "Welcome!"
// - another string- show "Wrong password"
// - for an empty string or cancelled input, show "Cancelled"
// empty string "", pressing 'Esc' returns null


let userName = prompt("Who's there?", "");

if (userName === 'Admin') {
  let pass = prompt('Password?',"");
  if ( pass === 'TheMaster') {
    alert('Welcome!');
  } else if ( pass === "" || pass === null) {
    alert('Canceled');
  } else {
    alert('Wrong password');
  }
} else if (userName === "" || userName === null) {
  alert('Canceled')
} else {
  alert("I don't know you")
}


// if runs if the condition is true
// else runs if the condition is false(runs another code instead of your 'if')
// else if specifies a new condition to test, if the first is false



const select = document.querySelector("#sunshine")
//   ^^^ document.querySelector is a method in javascript to recal certain elements of html
//        in this case, the id="sunshine"



element.addEventListener("event", function, useCapture);
// ^element=the HTML element to which the event listener is attached
// ^^("event")=a string representing the type of event like a click, keydown, or mouseover
// '( ,function, )'= the function to be called when the event occurs
// '(,, useCapture)' = is OPTIONAL, a boolean value specifying whether to use event capturing. This parameter is optional and is usually set to 'false' by default 

// .addEventListener is used to attach an event handler function to an HTML element
//  which allows you to respons to specific events like clicks, keypresses, or mouse movements on that element

select.addEventListener("change", setWeather)
// translates to:   'select' would be an HTML element from somewhere above in the code
// translates to:    when someone "changes" 'select', run the function 'setWeather' 





//You aboslutely can nest and if...else statement inside another one. 
if (choice === "sunny") {
  if (temperature < 86) {
    para.textContent = `It is $(temperature) degrees outside - nice and sunny. Let's go to the beach!`;
  } else if (temperature >= 86) {
    para.textContent = ` It is ${temperature} degrees outside - REALLY HOT.` 
  }
}

//REMEMBER logical operators help you write if...else statements without nesting
// && (AND) chains two or more expressions so all of them evaluates to true to work
// ||(OR) chains two or more expressions so ONE OR MORE evaluates to true
if (coice === "sunny" && temperature < 86) {
  para.textContent = `It is ${temperature} outside! Perfect Day`;
} else if (choice === "sunny" && temperature >= 86) {
  para.textContent = `It is ${temperature} outside! HOTHOTHOT`;
}
//NOTE that the first code block will only be run if 'sunny' and 'temp > 86' are true


if (iceCreamVanOutside || houseStatus === "on fire") {
  console.log("you should leave now!")
} else {
  console.log("Just stay inside I reckon");
}

// NOTE: it is iceCreamVanOutside !OR! houseStatus then it will execute


if (!(inceCreamVanOutside || houseStatus === "on fire")) {
  console.log("You are okay to stay");
} else {
  console.log("Get out!!!")
}
// NOTE that the ! around the first line of code will run the "NOT" operator
// This means that if the OR statement returns 'true' the ! will negate it so it will return false


// NOTE that you can also combine logical statements. but REMEMBER the precedence order
if ((x === 5 || y > 3 || z <= 10) && (loggedIn ||userName === "Steve")) {
}



//////WRONG BELOW:
if ( x === 5 || 7 || 10 || 20) {
  //run the code
}

//////CORRECT VERSION:
if (x === 5 || x === 7 || x === 10 || x === 20) {
  //run the code
}

//Note that first(wrong) code is saying 'if x equals 5, or 7'[which is always true]
//We want to specifiy a complete evaluation on both sides of the operator









/////BELOW IS ABOUT SWITCH STATEMENTS
// if...else statements do the job well when you have a couple of choices, and each requires a reasonable amount of code to be run and/or has mutliple logical operators
// when you only want to set a certain choice of value or print a particular statement dpending on a condition use switch
// Switch statements take a single expression/value as an input, and then looks through several choices until they find one that matches the value. and then executes it
switch (expression) {
  case choice1:
    //run this code
    break;

  case choice2: 
  //run this code instead
  break;

  case choice3:
    //include as many cases as you would like

  default:
    //actually, just run this code
    break;
}
// ABOVE EXPLANATION:
// - keyword of 'switch' followed by parentheses ()
// - an expression inside the parentheses ()
// - keyword of 'case', followed by a choice that the expression/value could be
// - some code to run[only if the value matches]
// - a 'break' statement, followed by a semicolon; 
// - if the previous choice matches the expression/value, the browser stops executing the code block there
// - and then moves on to any code that appears below the  switch (statement) { }
// - remember you can add as many cases as you want/need
// - the keyword 'default', followed by a code pattern but DOES NOT have a choice afer it
// - the DEFAULT option does not need a break after it as there is nothing to run after it
// - the DEFAULT option will run if none of the above codes match
// - NOTE: you also do not need to include a default section. UNLESS you are handling unknown cases
/////////////SAMPLE SWITCH STATEMENT/////////////////////////// HTML then JS
<label for="weather">Select the weather type today: </label>
<select id="weather">
  <option value="">--Make a choice--</option>
  <option value="sunny">Sunny</option>
  <option value="rainy">Rainy</option>
  <option value="snowing">Snowing</option>
  <option value="overcast">Overcast</option>
</select>

<p></p>
//////JS below:
const select = document.querySelector("select");
cont para = document.querySelector("p");

select.addEventListener("change", setWeather);

function setWeather() {
  const choice = select.value;

  switch (choice) {
    case "sunny":
      para.textContent = "It is nice and sunny! Wear shorts today.";
      break;
    case "rainy":
      para.textContent = "Bring your umbrella and trench coat!";
      break;
    case "snowing":
      para.textContent = "Snow Shoes and shovels today!";
      break;
    case "overcast":
      para.textContent = "Maybe it will rain, maybe it wont.";
      break;
    default:
      para.textContent = "";
  }
}






///TERNARY OPERATOR
// The Ternary or conditional operator is a bit of syntax that tests a condition and returns one value/expression if true
// and then returns another if it is false. This takes up less code than 'if...else' if you have two choices that are chosen in a true/false
condition ? run this code : run THIS code instead
// more clear
const greeting = isBirthday
? "Happy birthday! Have a wonderful day!"
: "Good Morning! Have a nice day!";
// the variable isBirthday, if true,(?) we give a custom birthday message
// if not (:) then a standard greeting is returned




//   HTML for ternary example2

<label for="theme">Select theme: </label>
<select id="theme">
  <option value="white">White</option>
  <option value="black">Black</option>
</select>

<h1>This is my website</h1>





///  JS for ternary example2
const select = document.querySelector("select");
const html = document.querySelector("html");
document.body.style.padding = "10px";

function update(bgColor, textColor) {
  html.style.backgroundColor = bgColor;
  html.style.color = textColor;
}

select.addEventListener("change",() =>
  select.value ==="black"
    ? update("black", "white")
    : update("white", "black"),
);
// the ternary order on bottom starts with a condition (selet.value === "black")
// (?) if that condition returns 'true', then run the update("black", "white") 
// (:) and if that condition returns 'false', then run update("white", "black") 






//test from lesson:
//Active learning: A simple calendar
//In this example, you are going to help us finish a simple calendar application. In the code you've got:
//A <select> element to allow the user to choose between different months.
//An 'onchange' event handler to detect when the value selected in the <select> menu is changed.
//A function called 'createCalendar()'' that draws the calendar and displays the correct month in the h1 element.

//We need you to write a conditional statement inside the 'onchange' handler function, just below the // ADD CONDITIONAL HERE comment. It should:

//Look at the selected month (stored in the 'choice' variable. This will be the <select> element value after the value changes, so "January" for example.)
//Set a variable called 'days' to be equal to the number of days in the selected month. To do this you'll have to look up the number of days in each month of the year. You can ignore leap years for the purposes of this example.
//Hints:
//You are advised to use logical OR to group multiple months together into a single condition; many of them share the same number of days.
//Think about which number of days is the most common, and use that as a default value.

let days = 31;
  if (choice === "February") {
    days = 28;
  } else if (
    choice === "April" ||
    choice === "June" ||
    choice === "September" ||
    choice === "November"
  ) {
    days = 30;
  }

  






  ////TEST 2 FROM LESSON:
  
  // Take the ternary operator example from earlier, and covert the ternary operator into a switch statement

// - This should accept the choice variable as its input expression
// - for each case the choice should equal one of the possible <option> values (white, black, purple, yellow, or psychedelic)
// - also for each case: the 'update()' function should be run and be passed two color values. 1 for bgColor and the second for textcolor
// - color value are strings so they must be wrapped in "quotes"

// Test is that the bottom of the website below if you want to try there before scrolling to the answer:
https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/conditionals



// YOU ARE GIVEN THE FOLLOWING


const select = document.querySelector('select');
const html = document.querySelector('.output');

select.addEventListener('change', () => {
  const choice = select.value;

//ADD SWITCH STATEMENT HERE
switch (choice) {
   case "white": 
	update("white","black");
	break;
   case "black":
 	update("black","white");
	break;
   case "purple":
	update("purple","yellow")
	break;
   case "yellow":
	update("yellow","purple")
	break;
   case "psychedelic":
	update("orange","blue")
	break;
}



function update(bgColor, textColor) {
  html.style.backgroundColor = bgColor;
  html.style.color = textColor;
}







//////  RANDOM NOTES TO KNOW:

//   - 0, NULL, "", UNDEFINED, NaN, and FALSE are all 'falsy' value

// you can pre evaluate a boolean
let cond = (year == 2023); //this evaluates to true or false
if (cond) {
  ...
}

// - 'else if' tests several different variants.
if (year < 2023) {
  alert("tooooo early");
} else if (year > 2023) {
  alert("tooooo late!");
} else {
  alert("Nailed it!");
}


/////////////// ? USE 
let age = prompt('age?', 18);

let message = (age < 3) ? 'Hi, baby!' :
  (age < 18) ? 'Hello!' :
  (age < 100) ? 'Greetings!' :
  'What an unusual age!';

alert( message );
////////////////////IS THE SAME AS BELOW:
if (age < 3) {
  message = 'Hi, baby!';
} else if (age < 18) {
  message = 'Hello!';
} else if (age < 100) {
  message = 'Greetings!';
} else {
  message = 'What an unusual age!';
}



////practice exercise:
let official = prompt("What is the official name of Javascript?");
let answer = "ECMAScript" 
if (official === answer) {
  message = 'Correct!';
} else {
  message = "you dont know? its ECMAScript"
}



///practice exercise 2:
let value = prompt("type a number!");
if (value > 0) {
  alert(1);
} else if (value < 0) {
  alert(-1);
}  else {
  alert(0);
}





////practice exercsie 3
let result = (a+b<4) ? 'below': 'over!'




/////practice exercise 4:
let message = (login == Employee) ? "hello" :
(login == 'Director') ? 'Greetings!' :
(login == 'No login') ? 'No login' :
'';
///is the translation of
let message;

if (login == 'Employee') {
  message = 'Hello';
} else if (login == 'Director') {
  message = 'Greetings';
} else if (login == '') {
  message = 'No login';
} else {
  message = '';
}










//////////// MORE ON THE SWITCH STATEMENT //////////////////////
// SYNTAX:
switch(x) {
  case 'value1': 
  //code goes here(alert("too small"))
  break;
  case 'value2':
  //different code (alert("perfect size"))
  break;
  case 'value3':
  //3rd code to try(alert("too big!"))
  break;

  //optional
  default:
    //code to run if all other cases fail
    break;
    //'break' is also optional when under the 'default' case
}
// live example
let a = 2 + 2;

switch(a) {
  case 3: 
  alert("under!");
  break;
  case 4: 
  alert("Nailed it!");
  break;
  case 5: 
  alert("getting too high!");
  break;
  default:
    alert("I dont know any values!");  
}
// the 'break' checks the case above it and run it if it returns 'true'
// case arguments can also be expressions (   case b+1:  )


// SEVERAL VARIANTS OF CASE WHICH SHARE THE SAME CODE CAN BE GROUPED.
// EXAMPLE BELOW: IF WE WANT TO RUN THE SAME CODE FOR 'CASE 3' AND 'CASE 5'
let a = 3;

switch(a) {
  case 4:
    alert("Correct!");
    break;
    case3:
    case5: 
    alert("Wronnngggg!");
    alert("take more classes!")
    break;
    default:
      alert("This result is a strange one. Really.");
}
//now both 3 and 5 show the same message
// the ability to 'group' cases is a side effect of how switch/case works without break. 
// case 3 starts and goes through line 5 becuase there is no break
// the above, when ran, would alert "wronnggggg!" and then alert "take more classes!"






///////TYPE MATTERS/////
// NOTE THAT THE EQUALITY CHECK IS ALWAYS STRICT. THE VALUES MUST BE OF THE SAME TYPE TO MATCH.
let arg = prompt("Enter a value?");
switch(arg) {
  case '0':
  case '1':
    alert("One or Zero");
    break;

    case '2':
      alert("Two");
      break;

    case 3:
      alert("Three");
      break;
      default:
        alert("An unknown value");
}
// '0' and '1', the first alert will run
// for '2', the second alert will run
// if you look closer at 3, the result of the prompt is a string, "3". which does not strictly === 3. 
// so case 3 is technically a dead code and the default variant will execute.

if (browser == 'Edge') {
  alert("You have got the edge")
} else if (browser == 'Chrome') ||
browser == 'Firefox' ||
browser == 'Safari' ||
broswer == 'Opera' {
  alert ("Okay, we support these too.")
} else {
  alert (" We hope that this looks okay!")
}

// REMEMBER THAT == DOES NOT CHECK FOR STRICT EQUALTIY
// REMEMBER THAT === DOES CHECK FOR STRICT EQUALITY (this will check both value and operand) and return false if they are different types







// practice work
let a = +prompt('a?','');

switch(a) {
  case 0:
    alert(0)
    break;

  case 1:
  alert(1);
  break;

  case 2:
  case 3:
  alert(2,3);
}









//////BREAKPOINTS
// these are used inside the dev tools in a browser therefore will not be used inside vscode or a script

line-of-code   // pauses an exact region of code
Conditional line-of-code   // pause on an exact region of code, but only when some other condition is true
logpoint   // log a message to the console without pausing the execution
DOM   // pause on the code that changes or removes a specific DOM node, or its children
XHR   // Pause when an XHR URL contains a string pattern
Event Listener    // Pause on the code that runs after an event is fired, such as a click
Exception    // Pause on the line of code that is throwing a caught or uncaught exception
Function    // Pause whenever a specific function is called
Trusted Type    // Pause on Trusted Type violations




//extra notes to add on the different breakpoints:


// DOM change breakpoints (elements tab) has 3 options to click from when you expand it from the right click menu
subtree modifications: //Triggered when a child of the currently-selected node is removed 
//or added, or the contents of a child are changed. Not triggered on child node attribute 
//changes, or on any changes to the currently-selected node.

Attributes modifications: //triggered when an attribute is added or removed on the 
// currently selected node, or when an attribute value changes

node removal: //triggerd when the currently-selected node is removed





// Short cuts inside the console of devtools



2+2
4
//to get to the previous value, type $_
$_
4

//you can also select up to the last 5 dom elements in the elements panel.
to refer to the most recent element, type 
$0 //most recent selected element
$1 //next most recent selected
$2 //and so on
$3 //and so on
$4 //and so on
//$4 is the most you can recall previous selected elements




short alias for .querySelector
$('selector name')
// the selector function returns the first element that matches the selector
$('selector', $0) //this will give you the first matching selector from the current element.
// the second optional argument in the $( , ) will tell you where are taking the selectors from

short alias for .querySelectorAll
$$('img', $0)
//this will pull all the "img" elements inside the current node or that belong the main element

//NOTE that you can right click on a returned result and select 'reveal in elements panel' to find it in a DOM






The x-path shortcut
$x(path[,startNode])

$x('//p')
//this will return ALL the <p> elements on the page
//this also can have an extra optional argument to specify more

$x("//p[a]")
// above will return all the <p> elements that contain <a> elements



queryObjects(Promise)
// the above will specify all 'promise' objects on your page


table(player)
//table is a shortcut to the table function 
// 'player' in this was already a set information



//extract object keys and values and copying

keys(player)
//this will discover the keys of an object. player being the object name
values(player)
// this will discover the values of an object. 'player' is still the object

//you can COPY all the value of the object
copy(value(player))
// note you still have to select the object name





monitoring from the console

//to see all the event listeners registered on a button
getEventListeners($0)
//note the $0 still means the current sleceted element

monitorEvents(window, 'resize')
//note that you must specify object and the event

unmonitorEvents
//will stop monitoring events


// You can also monintor function calls
//the console will log each function call ALONG with the arguments
monitor(sum)
//note in this instance, 'sum' is the argument






// deep dive on Console Utilities API reference

//remember: $_ gives the most recent value while $0 selects the most recent element

//NOTE: if the evaluated expression initially contains an array of names. you can use  
$_.length //to find th length of the array. the value changes to however many names are there
(4) [john, paul, george, ringo]
$_.length
//will reutrn '4'




$$(selector[,startNode])
$$(selector) //reutrns an array of elements that match the given css selector
// above is the equivalent of calling 
Array.from(document.querySelectorAll())


//NOTE the parameter startNode, specifies an element or Node from which to search for elements


clear()
//will clear the console. much like 'clear' will clear the terminal screen


copy(object)
// copies a string representation of the specified object to the 'clipboard'


debug(function)
//if a specified function is called, the debugger is invoke and breaks insdie the function on the sources panel
//this allows you to step through the code and debug it
undebug(fn)
//is used to stop breaking on the function, or use the UI to disable all breakpoints


dir(object)
//displays an object-style listing of all the specified object's properties.
/* this is a short cut for */ console.dir()


dirxml(object) 
//prints an XML representation of the specified object, as seen in the 'elements' panel.
/* this method is equivalent to the*/ console.dirxml()


inspect(object/function)
//opens and selects the specified element or object in the appropriate panel: 
// either the 'Elements' panel for DOM elements


getEventListeners(object)
// returns the event listeners registered on the specified object.
//the return value is an object that contains an array for each registered type(click/keydown)
getEventListeners(document)
// above will list all the event listeners registered on the 'document' object.



keys(object)
//returns an array containing the names of the properties belonging to the specified object
values() 
//will get the associated values of the same properties 
//for example: lets say your application defined this:
let player= {
  "name": "Parzival",
  "number": 1,
  "state": "ready",
  "easterEggs": 3
};
//typing the two following commands into the console will result in the following.
keys(player)
(4) ['name', 'number', 'state', 'easterEggs']
  0: "name"
  1: "number"
  2: "state"
  3: "easterEggs"
  length: 4
  [[prototype]]: Array(0)
values(player)
(4) ['Parzival', '1', 'ready', '3']
  0: "Parzival"
  1: "1"
  2: "ready"
  3: "3"
length: 4
[[prototype]]: Array(0)

//NOTE THAT THE VALUES ARE SPECIFICS




monitor(function)
//When the function specified is called, a message is logged to the console that indicates 
//the function name along with the arguments that are passed to the function when it was called.
/* REMEMBER TO USE*/ unmonitor(function) //to stop monitoring



monitorEvents(object[,events])
//when a specified event occurs on the specified object, the Eventis logged to the console.
monitorEvents(window, "resize");
//will log every time the window gets resized

//note that you can add to the events
monitorEvents(window, ["resize","scroll"])
// you can also specify one of the available event "types", strings that map to predefined sets of events.

//all mouse types
"mousedown", "mouseup", "click", "dblclick", "mousemove", "mouseover", "mouseout", "mousewheel"

//all key types
"keydown", "keyup", "keypress", "textInput"

//all touch types
"touchstart", "touchmove", "touchend", "touchcancel"

//all control types
"resize", "scroll", "zoom", "focus", "blur", "select", "change", "submit", "reset"





monitorEvents($0, "key");
// uses the "key" event type. All corresponding key events on an input text field currently selected($0)

/* REMEMBER TO USE */ unmonitorEvents(object[,events]) //to stop monitoring something





profile([name]) /*and*/ profileEnd([name])
//profile()starts a javascript CPU profiling session with an optional name. 
// profileEnd() completes the profile and diplays the results in the 'Performance > Main' track
//note that these are the shorthand for 'console.profile()' and 'console.profileEnd()'

//to start profiling:
profile("Profile 1")

//to stop profiling and see results in the 'Performance > Main' track
profileEnd("Profile 1")



queryObjects(Constructor)
//call this from the console to return an array of objects that were created with the specified constructor

queryObjects(promise) //returns every instance of 'promise'
queryObjects(HTMLElement) //returns all HTML elements
queryObjects(foo) // returns all objects that were instantiated via the class foo()



table(data[,columns])
//logs an object data with table formatting by passing in a data object in with optional column headings
/*above is a shortcut for*/ console.table()
//example:
let names = [
  {firstName: "John", lastName: "Smith"},
  {firstName: "Jane", lastName: "Doe"},
];
table(names);
//would display a table of the names with columns of (index), "first", "last", and any other info you have declared



undebug(function)
//stops the debugging of the specified function so that when the function is called
/*the debugger no longer is invoked. This is also used in concert wih*/ debug(fn)

unmonitor(function)
// stops the monitoring of the specified function. 
/* this is used in concert with */ monitor(fn)


unmonitorEvents(objects [,events])
// stops monitoring events for the specified object and events. 
unmonitorEvents(window)
//above will stop all event monitoring on the window object

//note that you can also stop specific events on an object
monitorEvents($0, "mouse");
unmonitorEvents($0, "mousemove");
//will start monitoring all 'mouse' events on the current selected element($0)
// this will also stop monitoring "mousemove" events (probably to reduce the noise in the output)








// more devtools tips


//regular
console.log('hello');

//Interpolated
console.log('hello I am a %s string!, '')
//interpolates whatever is in the second '', into the %s
//not used much since backticks can input varriables inside `` 

//styled
console.log('%c I am some good text', 'font-size: 50px')
//will style the text css style


//warning
console.warn('ohnoo');
//will return a warning on the console

//error
console.error('oh nooo')
//displays an error in the console


//info
console.info('Crocs eat 3-4 people per year')
//returns an 'info' line in the console


//testing
console.assert(1 === 2, 'You did not select the right element')
//assert only fires when something returns false(and then it will tell you in the console)
//This allows you to test for anything, and if it is wrong then it will tell the user in the console


//cleaning
console.clear()


//viewing DOM elements
console.log(p); //logs the dropdown
console.dir(p); //allows you to open the class list to show anything that lives on the element



//grouping
dogs.forEach(dog => {
  console.group(`${dog.name}`);
  console.log(`This is ${dog.name}`)
  console.log(`${dog.name} is ${dog.age * 7}dog years old`)
  console.groupEnd(`${dog.name}`);
})
//this is all a lot of stuff and a mess so the console.group cleans it up a bit



//counting
console.count('Wes');
console.count('Wes');
console.count('Wes');
console.count('Steve');
console.count('Steve');
console.count('Wes');
console.count('Wes');
console.count('Wes');
console.count('Steve');
console.count('Steve');
console.count('Wes');
console.count('Wes');
console.count('Wes');

//will log how many you have iterated over the code
/*wes 1
  wes 2
  wes 3
  steve 1
  steve 2
  wes 4 
  and so on */



  //timing
  console.time('fetching data');
  fetch('https://api.github.com/users/webos')
    .then(data => data.json())
    .then(data => {
      console.timeEnd('fetching data'); //pass the same string you use to start it
      console.log(data);
    });
// will reutrn the time it took to fetch the data 




console.table //remains important to take an array of objects and display them in a nice table









/////////FUNCTIONS--REUSABLE BLOCK OF CODE

/*Functions allow you to store a piece of code that does a single task insdie a defined block
and then call that code whenever you need it using a single short command */


//BUILT-IN BROWSER FUNCTIONS
/* - every time you have manipulated a text string, manipulated an array, or generated a random number
you have used functions built in to the browser */
const myText = "I am a string";
const newString = myText.replace("string", "sausage");
console.log(newString);
/* note that the replace() function takes a source string and a target string
then replaces the source string with the target, then returns the newly formed string*/

const myArray = ["I", "love", "chocolate", "frogs"];
const madeAString = myArray.join(" ");
console.log(madeAString);
// the join() function takes an array, joins
// all the array items together into a single
// string, and returns this new string

const myNumber = Math.random();
// the random() function generates a random number between
// 0 and up to but not including 1, and returns that number





// FUNCTIONS VS METHODS
// - NOTE THAT functions that are a part of objects are called methods.

// The "global object" can be  accessed using 'this' operartor in a global scope.
// the 'global scope' consists of the properties of the global object **including inherited properties**
// any other object created by the global scope are either created by the user script or provided by the host.

//Standard objects list by category


VALUE PROPERTIES   /* 
globalThis
Infinity
Nan
undefined
*/


FUNCTION PROPERTIES /*
eval()
isFinite()
isNan()
parseFloat()
parseInt()
decodeURI()
decodeURIComponent()
encodeURI()
encodeURIComponent()
escape()
unescape()
*/


FUNDAMENTAL OBJECTS  /*
Object
Function
Boolean
Symbol
*/


ERROR OBJECTS   /*
Eroor
AggregateError
EvalError
RangeError
ReferenceError
SyntaxError
TypeError
URIError
InternalError ---this is not standard and should not be used in production sites as it wont work for everyone
*/


NUMBERS AND DATES  /*
Number
BigInt
Math
Date
*/


TEXT PROCESSING  /*
String
RegExp
*/


INDEXED COLLECTIONS   /*
Array
Int8Array
Uint8Array
Uint8ClampedArray
Int16Array
Uint16Array
Int32Array
Uint32Array
BigInt64Array
Float32Array
Float64Array
*/


KEYED COLLECTIONS /*
Map
Set
WeakMap
WeakSet
*/



STRUCTURED DATA  /*
ArrayBuffer
SharedArrayBuffer
DataView
Atomics
JSON
*/


MANAGING MEMORY /*
WeakRef
FinalizationRegistry
*/ 


CONTROL ABSTRACTION OBJECTS  /*
Iterator
AsyncIterator
Promise
GeneratorFunction
AsyncGeneratorFunction
Generator
AsyncGenerator
AsyncFunction
*/ 


REFLECTION  /*
Reflect
Proxy
*/


INTERNATIONALIZATION  /*
Intl
Intl.Collator
Intl.DateTimeFormat
Intl.DisplayNames
Intl.DurationFormat
Intl.ListFormat
Intl.Locale
Intl.NumberFormat
Intl.PluralRules
Intl.RelativeTimeFormat
Intl.Segmenter
*/

custom functions //- are defined in your code, not inside the browser

function draw() {
  ctx.clearRect(0, 0, WIDTH, HEIGHT);
  for (let i = 0; i < 100; i++) {
    ctx.beginPath();
  ctx.fillStyle = "rgb(255 0 0 / 50%)";
  ctx.arc(random(WIDTH)), random(HEIGHT), random(50), 0, 2 * Math.PI);
  ctx.fill();
  } 
}
// The function above will draw 100 random circles insdie a (canvas) element.
// NOTE THAT EVERY TIME YOU WANT TO DO THAT, JUST INVOKE THE FUNCTION WITH:
draw() 

//functions can be called back to without writing all the code again. and you can even put functions inside functions like the 'random' we added above
function random(number) {
  return Math.fllor(Math.random() * number)
}
//we add this function because the browser's built in rng only generates a number between 0 and 1



//To invoke a function. include the name of the function inside the code followed by parentheses ()
function myfunction() {
  alert("Hello!");
}

myfunction();
//^^^will call the function once.








function jackieRob(num) {
  return num.toString();
}
console.log(jackieRob(42));
// a code that converts a number to a string. (This happens to be 42.)






//////////////////////////////
FUNCTION PARAMETERS: 

//Some functions require parameters to be specified when invoking (These are the values that need to be in parentheses)
// we have learned parameters a bit before and know them by their other names (ARGUMENTS, PROPERTIES, ATTRIBUTES)

const myNumber = Math.random();
//above function does not require any parameters 

const myText = " I am a string";
const newString = myText.replace("string", "sausage")
// the function above here uses multiple parameters
//NOTE THAT THE MULTIPLE PARAMETERS ARE SEPARATED BY A COMMA ,






OPTIONAL PARAMETERS

// you do not always need to specify parameters. If you do not, the function will adopt some kind of default behavior.
const myArray = ["I", "love", "chocolate", "frogs"];
const MadeAString = myArray.join("");
console.log(madeAString);
//this will return "I, love, chocolate, frogs" inside the console
// also NOTE that since no parameter was included to specify a joining/delimiting, a comma was used by default




DEFAULT PARAMETERS

//if you are writing a function and want to support optional parameters,
//you can specify default values by adding = after the name of the parameter, followed by the default parameter
function hello(name = "Chris") {
  console.log(`Hello $(name)!`);
}

hello("Ari");  //this will return "hello Ari"
Hello("Chris");  //This will return "hello Chris" because of the default we made above




ANONYMOUS FUNCTIONS AND ARROW FUNCTIONS
//Lets use this for example:
function myfunction() {
  alert("Hello!");
}

//you can also create a function that does NOT have a name(anonymous function)
(function () {
  alert("hello!")
});
// you will see anonymous functions when a function expects to receieve another function as a parameter
// In this case above, the function parameter is often passed as an anonymous function
////// NOTE!!!! THIS FORM OF CREATING A FUNCTION IS KNOWN AS "FUNCTION EXPRESSION". THESE TYPES ARE NOT HOISTED LIKE FUNCTION DECLARATION


//   ANONYMOUS FUNCTION EXAMPLE2:
addEventListener() 
// This function expects you to pass 2 parameters through the (), the name of the event to listen for, and a function to run when it happens

function logKey(event) {
  console.log(`you pressed "$(event.key)".`);
}
textBox.addEventListener("keydown", logKey);
/* above translation: when the user presses a key, the browser will call the function you provided, and will pass it a parameter 
containing info about this event, including the particular key that the user pressed       */



// instead of defining a separate 'logKey()' function, you can pass an anonymous function into addEventListener()
textBox.addEventListener("keydown", function (event) {
  console.log(`You pressed "$(event.key)".`);
});



// -----**********ARROW FUNCTIONS******************
parameter => parameter * parameter // basic syntax for an arrow function that takes a parameter and squares it
() => 10 // is syntax for an arrow function with no parameters(this happen to return the number 10)
(a,b) => a + b //syntax for a function that returns the sum of two parameters
// If a an arrow function has a block body meaning its enclosed in {}, you must include a 'return'  ex:
const add = (a,b) => {
  return a + b;
};

(x, y) => x + y //is an arrow function with an implicit return value. Since the function exists inside a single expression, it implicitly returns the result
() => ({a: 1, b: 2}) //When returning an object literal directly from an arrow function without using a block body, you need (parentheses) becuase {} denote starts and delimiters
// " This " in the context of an arrow function refers to the scope in which the arrow function was defined!
// Arrow functions can NOT be effectively used as methods in object literals to handle object properties because "this" inside an arrow function doesnt refer to the object its a method of
// If you try to access the 'arguments' object inside an arrow function, it refers to the arguments of the nearest non-arrow parent function.
x => x * 2 // is equivalent of writing:
function double(x) {
  return x * 2;
}
const message = () => alert("Hello World"); // arrow function with no arguments and returns a string



////////////////////// more on arrow functions:
let func = (arg1, arg2, ..., argN) => expression;
// this creates a function(func) that accepts arguments(arg1 to argN), then evaluates the 'expression' on the right sidr with their use and returns the result
// above is a shorter version of 
let func = function(arg1, arg2, ..., argN) {
  return expression;
};
///////more concrete example:
let sum = (a, b) => a + b; // translation: a function that accepts two arguments named 'a' and 'b'. Upon execution, it evaluates a+b and returns the result
/* This arrow function is a shorter form of:
let sum = function(a, b) {
  return a + b;
};
*/
alert( sum(1, 2) ); // 3


// If we have only one argument, then parentheses around parameters can be omitted. ( making it shorter)
let double = n => n * 2
alert( double(3)); //will return 6

// With no arguments, parentheses must be present! They are also empty!
let sayHi = () => alert("Hello!");


//arrow functions can be used in the same way as Function Expressions. 
// for example: to dynamically create a function:
let age = prompt("What is your age?", 18);
let welcome = (age < 18) ? //ternary operator meaning if age < 18 return 'true', then alert Hello! 
  () => alert("Hello!") : //ternary operator that if returns 'falsy' then alert greetings.
  () => alert("Greetings!");

welcome();






////////// MULTILINE ARROW FUNCTIONS
// the arrow functions we have seen above are very simple. Take the arguments from the left of => (the arrow), evaluated and returned the right-side expression.
// ---sometimes we need a more complex function, with multiple expressions and statements. We enclose them in curly braces, which require a return, 
let sum = (a, b) => {  // the curly brace opens a multiline function
  let result = a + b;
  return result; // if we use curly braces, then we need an explicit "return"
};
alert( sum(1, 2) ); // 3







///////SUMMARY ON ARROW FUNCTIONS (SO FAR. MORE TO COME!)
//---- Arrow functions come in 2 features, without curly braces {}. and with curly braces {}
//--without curly braces; the right side is evaluated and returned.
// -- with curly braces {}: we are allowed to write multiple statements inside the function. but we need an explicit 'return' inside the code







// if you pass an anonymous function like above this(arrow) section
//there's an alternative form you canuse, called an arrow function. instead of 'function(event)' you write =>
textBox.addEventListener("keydown", (event) => {
  console.log(`You pressed "$(event.key)".`)
});

//if the function takes only one parameter, you can omit the parentheses around the parameter
textBox.addEventListener("keydown", event => {
  console.log(`You pressed "$(event.key)".`)
});

/* NOTE!!!: if your function contains only one line that's a 'return' statement, you can also omit the braces
 and the 'return' keyword and implicitly return the expression      */
const originals = [1, 2, 3];

const doubled = originals.map(item => * 2);

console.log(doubled); //<<<<< will log '2, 4, 6' in the console
// the 'map()' method takes each item in the array in turn, passing it into the given function. 
// It then takes the value returned bu that function and adds it to a new array.

// IN THE ABOVE EXAMPLE:   'item => item * 2' is the arrow function equivalent of:
function doubleItem(item) {
  return item * 2
}

// you can also use the same syntax to rewrite the addEventListener example
textBox.addEventListener("keydown", (event) =>
  console.log(`You pressed "$(event.key)".`),
);
// in this case (above), the value of console.log() [which is undefined], is implicitly returned from the callback function.

// NOTE THAT IT IS RECOMMENDED TO USE ARROW FUNCTIONS, AS THEY CAN MAKE YOUR CODE SHORTER AND MORE READABLE.




// MORE NOTES ON FUNCTIONS TO REMEMBER 
Functions //are first-class objects becuase they can pass through other functions, returned from functions, and assigned to variables and properties
// THE DIFFERENCE BETWEEN A FUNCTION AND OBJECT IS THAT A FUNCTION CAN BE CALLED

/* NOTE THAT by default, if a function execution doesn't end at a return statement, or if the return keyword does NOT have
 an expression after it, then the return value is 'undefined'. The return statement allow you to return an arbitrary value from a function   */
// one function call will only return one value. but you can simulate the effect of returning multiple values by returning an object or array
// and then taking the result and destructuring it

// 'Destructuring' is a way to pull multiple arrays, values, or properties from objects into distinct variables

const [a, b] = array;
const [a , , b] = array;
const [a = aDefault, b] = array; 
const [a, b, ...rest] = array;
const [a , , b, ...rest] = array
const [a, b, ...{pop, push}] = array 
const [a, b, ...[c, d]] = array 

const { a,b } = obj;
const {a: a1, b: b1 } = obj;
const {a: a1 = aDefault, b: b1 = bDefault} - obj;
const {a, b, ...rest} = obj;
const {a: a1, b: b1, ...rest} = obj;
const { [key]: a} = obj;

let a, b, a1, b1, c, d, rest, pop, push;
[a, b] = array; 
[a, , b] = array;
[a = aDefault, b] = array;
[a, b, ...rest] = array;
[a, b, ...{pop, push}] = array;
[a, b, ...[c, d]] = array;

({ a, b } = obj);  //parentheses are REQUIRED
({ a: a1, b: b1 } = obj);
({a: a1 = aDefault, b: b1 = bDefault} = obj);
({ a, b, ...rest } = obj);
({ a: a1, b: b1, ...rest} = obj);




const [a, b] = array;
//This line extracts the first two elements of array and assigns them to a and b, respectively.

const [a, , b] = array;
//This extracts the first and third elements of array, skipping the second element. a gets the first element, b gets the third.

const [a = aDefault, b] = array;
//Here, a is assigned the first element of array, but if the first element is undefined, a defaults to aDefault. b gets the second element.

const [a, b, ...rest] = array;
//This extracts the first two elements as a and b, and the rest of the array elements are gathered into an array called rest.

const [a, , b, ...rest] = array;
//a receives the first element, the second element is skipped, b gets the third element, and the rest are collected in rest.

const [a, b, ...{pop, push}] = array;
//This line attempts to destructure pop and push methods (presumably from Array.prototype) from the remaining elements of array. However, this is not a valid JavaScript syntax and will result in a syntax error.

const [a, b, ...[c, d]] = array;
//a and b receive the first two elements, and then it attempts to destructure the remaining elements as an array [c, d]. However, this is not typical usage and may not work as expected in JavaScript.


//-------Object Destructuring
const { a, b } = obj;
//Extracts the properties a and b from obj and assigns them to variables a and b.
const { a: a1, b: b1 } = obj;
//Extracts properties a and b from obj, renaming them to a1 and b1.

const { a: a1 = aDefault, b: b1 = bDefault } = obj;
//Extracts a and b from obj, renaming them to a1 and b1. If a or b are undefined, they default to aDefault and bDefault, respectively.

const { a, b, ...rest } = obj;
//Extracts a and b, and gathers the rest of the properties of obj into an object rest.

const { a: a1, b: b1, ...rest } = obj;
//Similar to above but renames a to a1 and b to b1.

const { [key]: a } = obj;
//This uses the value of the variable key as the property name to extract from obj, and assigns it to a. The key must be defined elsewhere in the scope.

//----------Destructuring with Assignment
[a, b] = array;
//This assumes a and b are already declared. Assigns the first two elements of array to a and b.

[a, , b] = array;
//Assigns the first and third elements of array to a and b, skipping the second element.

[a = aDefault, b] = array;
//Assigns the first element to a, defaulting to aDefault if it's undefined. b gets the second element.

[a, b, ...rest] = array;
//Assigns the first two elements to a and b, and the rest to rest.

[a, b, ...{pop, push}] = array;
//This is an invalid syntax in JavaScript and will result in an error.

[a, b, ...[c, d]] = array;
//Assigns the first two elements to a and b, and attempts to destructure the rest as [c, d], which is unusual and may not work as expected.

//----------Destructuring with Object Assignment
({ a, b } = obj);
//Parentheses are required when using object destructuring assignment outside a declaration. Extracts a and b from obj.

({ a: a1, b: b1 } = obj);
//Extracts a and b from obj, renaming them to a1 and b1.

({ a: a1 = aDefault, b: b1 = bDefault } = obj);
//Extracts a and b, renaming and defaulting them as necessary.

({ a, b, ...rest } = obj);
//Extracts a and b, and assigns the rest of obj's properties to rest.

({ a: a1, b: b1, ...rest } = obj);
//Extracts and renames a and b, and assigns the rest of obj's properties to rest.



//The object and array literal expressions provide an easy way to creare ad hoc packages of data
const x = [1, 2, 3, 4, 5];
// the destructuring assignment uses similar syntax but uses it on the left-hand side of the assignment instead. 
// It defines which values to unpack from the sourced variable
const x = [ 1, 2, 3, 4, 5];
const [y, z] = x;
console.log(y); //will return 1
console.log(z); // will return 2 
// NOTE that similarly, you vcan destructure objects on the left-hand side of the assignment
const obj = { a: 1, b: 2};
const {a,b} = obj;
/* is equivalent to:
const a = obj.a;
const b = obj.b;
*/
//This capability is similar to features present in languages such as Perl and Python.







///////////// MORE ON FUNCTION EXPRESSSIONS
const square = function (number) {
  return number * number;
};
console.log(square(4)); //will return 16
// function CAN be previded with a function expression. Providing a name allows the function to refer to itself
// and it also allows the function to refer to itself and also makes it easier to identify the function in a debugger's stack traces.
const factorial = function fac(n) {
  return n < 2 ? 1 : n * fac(n-1);
};
console.log(factorial(3)); //will return 6
/* REMEMBER THAT < ? AND : are all ternary operators and are short for if-else statements; so
The condition n < 2 checks if n is less than 2.
If the condition is true (meaning n is 0 or 1), the function returns 1. This is because the factorial of 0 and 1 is 1.
If the condition is false (meaning n is greater than or equal to 2), the function returns n * fac(n - 1).
 This is the recursive call, where the function calls itself with n - 1.
*/

/*FUNCTION EXPRESSIONS are convenient when passing a function as an argument to another function. */
function map(f, a) {
  const result = new Array(a.length);
  for (let i = 0; i < a.length; i++) {
    result[i] = f(a[i]);
  }
  return result;
}
/* step by step break down of above:
1) function declaration:
'function map'-declares the function with two parameters

2) creating the new Array for results:
'const result = new Array(a.length);'-initializes the new array names 'result'
with the same length as the input array `a`. This array will be used to store the 
results of appplying the function 'f' to each element of 'a'

3) Looping through the array:
the 'for loop' (for(leti=0...)) iterates over each element of the input array `a`
'let i = 0' initializes a loop counter `i` to `0`
'i < a.length' is the loop condition, which continues the loop as long as `i`
is less than the length of the array `a`

4)applying the function to each element:
`result[i] = f(a[i]); - inside the loop function `f` is called 
with the current element of the array `a` as its argument... the result of this function
call is then reassigned to the corresponding index `i` in the `result` array

5)Returning the result:
`return result` --once the loop completes, the `result` array, which now contains the
results of applying `f` to each element of `a` is returned.
*/


///////example 2 (added more to the above code)
function map(f, a) {
  const result = new Array(a.length);
  for (let i = 0; i < a.length; i++) {
    result[i] = f(a[i]);
  }
  return result;
}

const cube = function (x) {
  return x * x * x;
};

const numbers = [0, 1, 2, 5, 10];
console.log(map(cube, numbers)); // will return [0, 1, 8, 125, 1000]
// the function above receives a function defined by a function expression and executes it for every element of the array received as a 2nd argument



// Write a loop in Javascript that repeats 5 times.
for (let i = 0; i < 5; i++); {
  //whatever code to be executed for each iteration (1,2,3,4... as long as i < 5. Then it stops.)
}








//NOTE THAT IN JS: a function can be defined based on a condition. For example: the following function definition defines 'myFunc' only if 'num' = 0
let myFunc;
if (num === 0) {
  myFunc = function (theObject) {
    theObject.make = 'Toyota';
  }
}




////////// MORE NOTES ON 'CALLING FUNCTIONS'
// NOTE that just becauase you define a function, does not mean you execute it. Defining it NAMES and SPECIFIES what to do when a function is called
square(5);
//above calls the function with an 'argument' of 5; the function executes the statement and returns the value of 25

//NOTE: that functions must be in scope when they are called, but the function declaration can be 'hoisted'(which means it appears below the call in the code)
// the arguments of a function are not limited to strings and numbers. you can pass whole objects to a function. 'showProps' function is an example of that:
function factorial(n) {
  if ( n === 0 || n === 1) {
    return 1;
  } else {
    return n * factorial(n-1);
  }
}
// YOU COULD THEN FIGURE OUT THE FACTORIAL RETURNS OF 1-5 LIKE BELOW:
console.log(factorial(1)); // will return 1
console.log(factorial(2)); // will return 2
console.log(factorial(3)); // will return 6
console.log(factorial(4)); // will return 24
console.log(factorial(5)); // will return 120
// NOTE that there are other ways to call functions as well. There are often cases where a function needs to be called dynamically,
// or the number of arguments to a function vary, or in which the context of the function call needs to be set to a sepcific object 
// NOTE that functions are 'objects', and in turn, these objects have methods. call() and apply() methods can be used to achieve this goal





///////   FUNCTION HOISTING
console.log(square(5)); //returns 25

function square(n) {
  return n * n;
}
// the code above will run without any error, despite the square() function being called before its declared.
//This is because the Javascript interpreter hoists the entire function declaration to the top of the current scope. 
// the above code is equivalent to:
function square(n) {
  return n * n;
}
console.log(square(5)); //returns 25
//NOTE THAT: all function declaration are effectively at the top of the scope.
// BIG NOTE THAT: hoisting only works with function 'declarations'- and NOT with function expression. 
//The following code below, will NOT work:
console.log(square(5)); 
const square = function (n) {
  return n * n;
}
//will return a ReferenceError: cannot access 'square' before initialization 






//////// FUNCTION SCOPE
/*NOTE THAT variables defined inside a function cannot be accessed from anywhere outside the function,
 because the variable is only defined in the scope of the function...
 REMEMBER that a function can access all variables and functions defined inside the scope in which it is defined.

 In other words: a function defined in the global scope can access all variables defined in the global scope.
 a function defined inside another function can also access all variables defined in its parent function, and any other variables ot which the parent has access to
*/

//NOTE THAT THE FOLLOWING IS DEFINED IN A GLOBAL SCOPE
const num1 = 20;
const num2 = 3;
const name = "Tyler";


//The function below is also defined in the global scope
function multiply() {
  return num1 * num2;
}
console.log(multiply()); //will return 60



//below is a 'nested' function example:
function getScore() {
  const num1 = 2;
  const num2 = 3;

  function add() {
    return `${name} scored ${num1 + num2}`;
  }
  return add();
}

]console.log(getScore()); // will return "Tyler scored 5"






/////Scope and the function stack

// *****RECURSION******//
/*NOTE: that a function can refer to and call itself. There are three ways for a function to refer to itself.
1) the function's name
2)arguments.callee
3) an in-scope variable that refers to the function
(example below)
*/
const foo = function bar() {
  //statements go here
}
bar(), arguments.callee(), and foo() //are ALL equivalent

//REMEMBER THAT a function that calls itself is called a recursive function.
//NOTE that a recursion is analogous to a loop. Both execute the same code mutiple times and both require a condition(to avoid infinite loops/recursion)
//example below:
let x = 0;
//"x<10" is the loop condition
while( x < 10 ) {
  //do stuff
  x++
}
//the above can be converted into a recursive function declaration, followed by a call to that function
function loop(x) {
  // X>10 is the exit condition(equivalent to '!(x<10)')
  if ( x >= 10 ) {
    return;
  }
  //do stuff
  loop ( x + 1 ); //the recursive call
}
loop(0);



//HOWEVER!!! NOTE that some alogirthms cannot be simple iterative loops. For example, getting all the nodes of a tree structure(such as the DOM) is easier via recursion
function walkTree(node) {
  if (node === null) {
    return;
  }
  //do something with node
  for (let i = 0; i < node.childNodes.length; i++) {
    walkTree(node.childNodes[i]);
  }
}
// NOTE that compared to the function loop, each recursive call makes many recursive calls here
// IT IS POSSIBLE to convert any recursive algorithm to a non-recursive one, but is often too complex and requires use of a stack.
//stack can be seen below:
function foo(i) {
if ( i < 0 ) {
  return;
}
console.log(`begin: ${i}`);
foo ( i - i );
console.log(`end: ${i}`);
}
foo(3);
/*logs:
begin: 3
begin: 2
begin: 1
begin: 0
end: 0
end: 1
end: 2
end: 3
*/






/////// NESTED FUNCTIONS AND CLOSURES
// REMEMBER that you can nest a function inside another function. The nested(inner) function is private to its containing(outer) function
/* This also forms a 'CLOSURE'. a closure is an expression(most commonly, a function) that can have free variables together with 
an environment that binds those variables (or 'closes' the expression)
*/
//NOTE that nested functions can "inherit" the arguments and variables of its containing function

//IN OTHER WORDS:
// 1- THE INNER FUNCTION CAN BE ACCESSED ONLY FROM STATEMENTS IN THE OUTER FUNCTION
/* 2 - THE INNER FUNCTION FORMS A CLOSURE: THE INNER FUNCTION CAN USE THE ARGUMENTS AND VARIABLES OF THE OUTER FUNCTION, WHILE THE OUTER FUNCTION
CANNOT USE THE ARGUMENTS AND VARIABLES OF THE INNER FUNCTION */ 
function addSquares(a,b) {
  function square(x) {
    return x * x;
  }
  return square(a) + square(b);
}

console.log(addSquares(2,3)); // will return 13 because x * x makes it (2*2) + (3*3)
console.log(addSquares(3,4)); // will return 25
console.log(addSquares(4,5)); // will return 41
//SINCE the inner functions forms a closure, you can call the outer function and specify arguments for both the outer and inner function
function outside(x) {
  function inside(y) {
    return x + y;
  }
  return inside;
}

const fnInside = outside(3); // think of this like: 'give me a function that adds 3 to whatever you give it'
console.log(fnInside(5));// will return 8 
console.log(outside(3)(5));




//////PERSERVATION OF VARIABLES
// NOTE that in the above example, the 'x' is preserved when INSIDE is returned. A closure must preserve the arguments and variables in all scopes.
// NOTE that each call will provide potentially different arguemnts, a new closure is created for each call to 'outside'
// The memory can be freed only when the returned 'inside is no longer accessible'





//////////MULTIPLY-NESTED FUNCTIONS
/*NOTE that this does not mean mutiplying functions (x*x). Multiply-nested functions are another method for functions.
 -- a function(a) contains a function(b), which itself contains a function(c)
 -- both functions 'b' and 'c' form closures here. So, 'b' can access 'a' and 'c' can access 'b'
 -- in addition, since 'c' can access 'b' which can access 'a'. then 'c' can also access 'a'

 Thus, the closures can contain multiple scopes; they recursively contain the scope of the functions containing it. 
 ^^^^This is called 'Scope Chaining' (chaining comes later)
*/
function A(x) {
  function B(y) {
    function C(z) {
      consoloe.log( x + y + z );
    }
    C(3);
  }
  B(2);
}
A(1);  // will log '6' becuase 1 + 2 + 3 or x + y + z
/* The example above, c accesses B's y, and A's x
 1) B forms a closure including A.(meaning B can access A's arguments and variables)
 2) C forms a closure including B
 3) because C's closure includes B and B's closure includes A, then C's closure also includes A.
 meaning that C can access both B and A's arguments and variables. In other words, C chains the scopes of B and A IN THAT ORDER

  NOTE TO REMEMBER:!!! A cannot access C because A cannot access any arguments or variables in B(which C is a variable of)(thus C remains private to B)
*/






//////////// NAME CONFLICTS (When two arguments or variables in the scopes of a closure have the same name)
// NOTE that [most] nested scopes take precedence. So, the innermost scope takes the highest precedence, while the outermost scope takes lowest.
// Above is what is known as a 'SCOPE CHAIN'. 
// REMEMBER that the first on the chain is the innermost scope, and the last is the outermost scope. :::
function outside() {
  const x = 5;
  function inside(x) {
    return x * 2;
  }
  return inside;
}
console.log(outside()(10)); // returns 20 (instead of 10)
// SEE the name conflict happen at the statement ' return x * 2 ' and is between 'inside's' parameter x and 'outside's' variable x.
// the scope chain here is {inside, outside, global object}. therefore, inside's X takes precedences over outside's X AND 20(which is inside's X) is returned 









//////////    CLOSURES    !!!! (ONE OF THE MOST POWERFUL FEATURES IN JAVASCRIPT)
 /* 
JS allows for the nesting of functions and grants the inner function full access to all the variables and functions defined inside the outer function

HOWEVER: the outer function does NOT have access to the variables and functions defined inside the inner function.

ANOTHER NOTE: since the inner function has access to the scope of the outer function, the variables and functions defined in the outer function
will live longer than the duration of the outer function execution, if the inner function manages to survive beyond the life of the outer function
---A closure is created when the inner function is somehow made available to any scope outside the outer function
 */
// the outer functions defines a variable called "name"
const pet = function (name) {
  const getName = function () {
    return name; //the inner function has access to the "name" variable of the outer function 
  };
  return getName; // Return the inner function, thereby exposing it to outer scopes
};
const myPet = pet("Vivie");

console.log(myPet()); //will return Vivie


// MORE COMPLICATED: an object containing methods for manipulating the inner variables of the outer function can be returned
const createPet = function (name) {
  let sex;

  const pet = {
    // setName(newName) is equivalent to setName: function (newName)
    // in this context
    setName(newName) {
      name = newName;
    },

    getName() {
      return name;
    },

    getSex() {
      return sex;
    },

    setSex(newSex) {
      if (
        typeof newSex === "string" &&
        (newSex.toLowerCase() === "male" || newSex.toLowerCase() === "female")
      ) {
        sex = newSex;
      }
    },
  };

  return pet;
};

const pet = createPet("Vivie");
console.log(pet.getName()); // Vivie

pet.setName("Oliver");
pet.setSex("male");
console.log(pet.getSex()); // male
console.log(pet.getName()); // Oliver

/* THE CODE ABOVE: the 'name' variable of the outer function is accessible to the inner functions,
and there is no other way to access the inner variables EXCEPT through the inner functions. 
The inner variables of the inner functions act as safe stores for the outer arguments and variables. They hold "persistent" and "encapsulated"
data for the inner functions to work with. The functions do not even have to be assigned to a variable, or have a name
*/
const getCode = (function () {
  const apiCode = "OJEal(eh&2"; //a code that we do NOT want outsiders to modify
  
  return function () {
    return apiCode;
  }
})();

console.log(getCode()); //will return OJEal(eh&2




//NOTE THAT if an enclosed function defines a variable with the same name as a variable in the outer scope, then there is no way to refer
// to the variable in the outer scope again. (The inner scope variable "overrides" the outter one, until the program exits the inner scope. Can be thought of as name conflict)









///////// USING THE ARGUMENTS OBJECT (the arguments of a function are maintained in an array-like object. Within a function, you can address the arguments:)
arguments[i];
// where 'i' is the ordinal number of the arguemnt, starting at 0. So, the first argument passed to a function would be arguments[0].
//  the total number of arguments is indicated by arguments.length

//NOTE that you can use the arguments object to call a function with more arguments than it is formally declared to accept. 
// ^^^^^^this is useful if you don't know in advance how many arguments will be passed to the function. 
function myConcat(separator) {
  let result = ""; //initialize list
  //itterate through arguments
  for (let i = 0); i < arguemnts.length; i++) {
    result += arguments[i] + seperator;
  }
  return result;
}
//NOTE that you can pass any number of arguments through the function, and it concatenates each argument into a string "list".
console.log(myConcat(",", "red", "orange", "blue"));
//will return 'red, orange, blue'
console.log(myConcat(";", "elephant", "giraffe", "lion", "cheetah"));
// will return "elephant; giraffe; lion; cheetah"
console.log(myConcat(".", "sage", "basil", "oregano", "pepper", "parsley"));
// will return 'sage. basil. oregano. pepper. parsley'
//////// NOTE THE FIRST ARGUMENT CONTROLS HOW THE LISTS ARE SEPARATED.









////////////ARROW FUNCTION LIVE EXAMPLE
//NOTE that it is problematic to use an arrow function as an event holder in the DOM
// because it will not have its own 'this'. 'this' is arrow functions refer to the surrounding lexical context
//html first:
<input id="textBox" type="text" />
<div id="output"></div>


//js for this
const textBox = document.querySelector("#textBox");
const output = document.querySelector("#output");

textBox.addEventListener("keydown", (event) => {
  output.textContent = `You pressed "${event.key}".`;
});

//the "keydown" event triggers the event and makes the text.content of the 'output' "you pressed${event.key}" which in this case (event.key) is the key you pressed down to type








//////// FUNCTION SCOPE AND CONFLICTS
// When you create a function, the variables and other things defined inside the function are inside their own separate scope.
// (meaning they are locked away in their own separate compartments, unreachable from code outside the functions.)
//NOTE: the Top level outside all your functions is called the GLOBAL SCOPE. Values defined in the global scope are accessable from everywhere in the code.
//JS is set up like this for security and organization. Sometimes you dont want variables accessed from everywhere in the code
/* TO EXPAND ON FUNCTION SCOPE::
Function scope is a fundamental concept in programming that refers to the visibility and accessibility of variables and other resources within a function.
When a variable is defined inside a function, it is only accessible and modifiable within that function. This localization of variables and other entities to the function in which they are declared helps to:

1- Prevent Naming Conflicts: By ensuring that variables within a function do not interfere with variables outside the function or in other functions,
function scope reduces the likelihood of accidental interactions between different parts of the code. This is especially important in large codebases where the same variable name might be used in different contexts.

2- Improve Code Modularity: Function scope contributes to cleaner, more modular code. Functions can be written, tested, and debugged more easily when their internal workings are self-contained.

3- Enhance Code Readability and Maintenance: With function scope, developers can understand and maintain code more easily
because the context of each variable is limited to the function in which it is used. This makes it easier to track the flow of data and the logic of the program.

4- Encourage Good Programming Practices: Function scope encourages developers to think carefully about the design of their functions,
leading to better programming practices such as avoiding the use of global variables, which can lead to unpredictable code behavior.

Overall, function scope is essential for creating reliable, maintainable, and understandable code, especially as software projects grow in complexity.
*/

// Excerpt from my HTML
<script src="first.js"></script>
<script src="second.js"></script>
<script>
  greeting();
</script>

// first.js
const name = "Chris";
function greeting() {
  alert(`Hello ${name}: welcome to our company.`);
}

// second.js
const name = "Zaptec";
function greeting() {
  alert(`Our company is called ${name}.`);
}

//NOTE that both functions you want to call are called 'greeting()' but you can only ever access the 'first.js' file's 'greeting()' (the 2nd is ignored)
// in addition, an error results when attempting (in the 2nd .js file) to assign a new value to the 'name' variable
// ^^^^^becuase it was already declared with 'const' and so cant be reassigned.

//zoo keeper is like a global scope. (they have access to each individual variable in the zoo)
// the Lions, Tigers, Zebras, and Bears all only have access to their own variables inside their own closures.






///////TEST QUESTIONS WITH GPT ANSWERS/NOTES TO REMEMBER

// after variables are accessed in their own functions, they become invisible/inaccessible to functions below that 
/* function scope is a key concept in programming that contributes significantly to:
Security: limits the accessability of variables to the functions where they are defined. reduces risk of bugs and vulnerabilities

Organization: encourages devs to think of discrete, self-contained units of code. 

Maintainability: It is easier to track down variables when they are scoped to functions. more readable and easier to use code is made

prevention of side effects: function scope helps in redcing side effects by keeping variables local to functions. minimize any potential sideeffect

Modular Design: each function can be developed, tested, and debuged idependently. This is vital for scalability and reusability of code in large-scale projects

*/





//////////// FUNCTION RETURN VALUES!!!!
// return values are exactly what it sounds like. They are the values that a function returns when it completes.
const myText = "The weather is cold";
const newString = myText.replace("cold", "warm");
console.log(newString); // Should print "The weather is warm"
// the replace() string function takes a string,
// replaces one substring with another, and returns
// a new string with the replacement made


//NOTE that some functions do NOT return any value. a 'displayMessage()' function does not have a reutrn value becuase the function just displays a textbox
// generally a reutrn value is used where the function is an itnermediate step in a calculation of some kind. You want to get a final result
// which involves some values that need to be calculated by a function. After the function calculates the value, it can return the result,
// so it can be stored in a variable; and you can use this variable in the next stage of the calculation.

/////////USING REUTRN VALUES IN YOUR OWN FUNCTIONS
//    To return a value from a custom function; you need to use the 'return' keyword. (we seen this used in the random-canvas-circles example)
function draw() {
  ctx.clearRect(0, 0, WIDTH, HEIGHT);
  for (let i = 0; i < 100; i++) {
    ctx.beginPath();
    ctx.fillStyle = "rgb(255 0 0 / 50%)";
    ctx.arc(random(WIDTH), random(HEIGHT), random(50), 0, 2 * Math.PI);
    ctx.fill();
  }
}
// inside each loop iteration, three calls are made to the random() function, to generate a random value for the current circle's x, y, and radius
// the random() function takes one parameter[a whole number]and returns a whole random number between 0 and that number.
function random(number) {
  return Math.floor(Math.random() * number);
}
//can be written like this:
function random(number) {
  const result = Math.floor(Math.random() * number);
  return result;
}
//but we use the first version, becuase it is quicker and much more compact to write.
// we are returning the result of the calculation 'Math.floor(Math.random() * number)'
// this return value appears at the point the function was called, and the code continues. so when you execute the follwing:
ctx.arc(random(WIDTH), random(HEIGHT), random(50), 0, 2 * Math.PI);
// if the three random() calls return the values 500, 200, and 35 =, respectively, the line would actually be run as if it were this:
ctx.arc(500, 200, 35, 0, 2 * Math.PI);
// the function calls on the line are run first, and their return values are substituted for the function calls, before the line itself is then executed


input.addEventListener("change", () => {
  //the above adds a listener the event 'change'. This means whenever a 'change' is fired(entering letters/numbers then hitting 'enter'/'tab')








/////////// Parameters and arguments continued

// Parameters are the items listed between the parentheses in the function declaration.
// Function arguments are the actual values we decide to pass to the function. 

function favoriteAnimal(animal) {    //function definition(PARAMETER)     //the PARAMETER can be anything(pet, x, blah) but someone reading it needs to understand it
  //putting 'animal' inside the parentheses is telling javascript that we will send some value to our function; and 'animal' is just a place holder
  return animal + "is my favorite animal!"
}
console.log('Goat') //this is where we call the function to pass a value. 'Goat' here is the ARGUMENT
//ALWAYS CONSOLE.LOG AT THE END OF A FUNCTION!! IF YOU DO NOT, NOTHING APPEARS IN THE CONSOLE, BUT THE FUNCTION STILL RETURNS THE STRING/VALUE












/////////////////function/parameter/return values review:
function declaration (parameter1, parameter2) {
  function body 
}

// ----a variable declared inside a function is only visible inside that function
function showMessage() {
  let message = "Hello, I'm JavaScript!"; // local variable
  alert( message );
}
showMessage(); // Hello, I'm JavaScript!
alert( message ); // <-- Error! The variable is local to the function


//----a function can access an outer variable as well:
let userName = 'John';

function showMessage() {
  let message = 'Hello, ' + userName;
  alert(message);
}
showMessage(); // Hello, John


//----the function has full access to the outer variable. It can modify it as well:
let userName = 'John';

function showMessage() {
  userName = "Bob"; // (1) changed the outer variable

  let message = 'Hello, ' + userName;
  alert(message);
}
alert( userName ); // John before the function call
showMessage();
alert( userName ); // Bob, the value was modified by the function

//-- the outer variable is only used if there's no local one.


//----if a same-named variable is declared inside the function, then it shadows the outer one. 
let userName = 'John';
function showMessage() {
  let userName = "Bob"; // declare a local variable
  let message = 'Hello, ' + userName; // Bob
  alert(message);
}
// the function will create and use its own userName
showMessage();
alert( userName ); // John, unchanged, the function did not access the outer variable

//----Global variables are visible from any function(unless shadowed by locals)








//----We can pass arbitrary data to functions using PARAMETERS

function showMessage(from, text) { // parameters are: from, text
  alert(from + ': ' + text);
}
showMessage('Ann', 'Hello!'); // Ann: Hello! (*)
showMessage('Ann', "What's up?"); // Ann: What's up? (**)
//translation: "the function showMessage() is declared with two parameters, then called with two arguments 'from' and 'hello' " 

//when the function is called in lines (*) and (**), the given values are copied to local variables 'from' and 'text'. then the function uses them.



//---when a value is passed as a function parameter, it is also called an ARGUMENT
//- A PARAMETER is the variable listed inside the parentheses in the 'function declaration' (it is a declaration time term)
//- An ARGUMENT is the value that is passed to the function when it is called. (it is a call time term)

// ORDER OF EVENTS: declare functions(listing their parameters), then call them passing arguments





///////////////DEFAULT VALUES

//-----if a function is called, but an argument is not provided, then the corresponding value becomes 'undefined'
showMessage("Ann") //from before, can be called using a single argument

//---we can specify the "default" (to use if ommited) value for a parameter in the function declaration using, =
function showMessage(from, text = "no text given") {
  alert( from + ": " + text );
}
showMessage("Ann"); // Ann: no text given
// note that if the 'text' parameter is not passed, it will get the value "no text given"
// - EXTRA NOTE: that the default value also jumps in if the parameter exists, but strictly equals 'undefined'
showMessage("Ann", undefined); //Ann: no text given
// above: "no text given" is a string, but it can be a more complex expression, which is only evaluated and assigned if the parameter is missing
function showMessage(from, text = anotherFunction()) {
  //anotherFunction() is only executed if no text given
  //its result becomes the value of text
}


//return values are important because they have the ability to pass data back from a function to the point where the function was called.
// allows for modular, flexible code where one function can perform a specific task and then communicate the result back to other parts of the program


//---VOID FUNCTIONS: refers to a function that does not return any value. When we say a function is void, it means that its purpose is to
//                   perform an action rather than calculate a value to be returned. The term "void" is used in some programming languages
//                   to explicitly indicate that a function does not return anything.

// Void function are often used for their side effects, such as printing to the console, modifying global variables, writing to a file, or updating a U.I.
// These function do their job and then exit without providing a return value.




//---- Local variables are defined inside of a function. and can only be accessed within the function where they are declared.
//---- Global variables are declared outside of any function. they can be accessed and modified from any part of the program, including within functions.







//----Different ways to pass arguments to a function:

// - by VALUE:This is the most common way of passing arguments and is used for immutable data types like strings and numbers. 
//    When data is passed by value, the function receives a copy of the argument, not the original value. 
//    Any changes made to the argument inside the function do not affect the original value outside the function.

// by REFERENCE: This method is used for mutable data types, like objects and arrays in JavaScript. When an object or an array is passed as an argument,
//    the function receives a reference to the original data, not a copy. This means that changes made to the object or array within the function 
//    will affect the original object or array outside the function.

// using REST PARAMETERS: In some languages like JavaScript, you can use rest parameters to pass an indefinite number of arguments to a function. 
//    This is done using the '...' syntax. The function treats these arguments as an array.

// PASSING FUNCTIONS AS ARGUMENTS: Functions can also be passed as arguments to other functions. 
//    This is a common pattern in JavaScript, particularly in higher-order functions.

// DESTRUCTING: In languages that support destructuring, like modern JavaScript, you can pass an object to a function and 
//    then destructure its properties within the function's parameter list.
function modifyArray(arr) {
  arr.push(4); // This will modify the original array
}

function sum(...numbers) {
  return numbers.reduce((a, b) => a + b, 0);
}

let myArray = [1, 2, 3];
modifyArray(myArray); // Passed by reference
console.log(myArray); // Outputs: [1, 2, 3, 4]

console.log(sum(1, 2, 3, 4)); // Using rest parameters, outputs: 10

//ABOVE: 'modifyArray' modifies the orginal array becuase arrays are passed by reference
// 'sum' uses rest parameters to accept any number of arguments



//--- Immutable types such as strings and numbers receive a copy of the value when passed.
//--- Mutable types such as objects and arrays receive a reference to the original, not a copy
function modifyObject(obj) {
  obj.newProperty = 'Added in function';
}

let myObject = { property: 'Original' };
modifyObject(myObject);
console.log(myObject); // Outputs: { property: 'Original', newProperty: 'Added in function' }
//above: 'myObject' is passed to 'modifyObject'. Since objects are mutable and passed by reference, the function adds a new property to the same object,
//    which is then reflected in the original 'myObject'.





//return MULTIPLE VALUES by destructuring. (which is a way to pull multiple arrays, values, or properties from objects into distinct variables)






// ----- REMEMBER THAT arrow functions can NOT be used as constructors in javascript.

//---in js, constructor functions are used to create objects. They are defined using regular function expressions or function declarations.
//    This creates a new object that inherits properties and methods from the constructor's prototype. 

// 1-- there is no 'this' binding in arrow functions. the binding is crutial because it refers to the new object that is being created
// 2-- no "new" target. Arrow function DO NOT have a construct method(which is required for a function to be called with 'new')
// 3-- no 'prototype' property. arrow functions do NOT have a 'prototype' property, making them unsuitable for use as constructors
// Regular function as a constructor
function RegularFunction() {
    this.property = 'value';
}
const obj1 = new RegularFunction();
console.log(obj1.property); // Outputs: 'value'

// Attempting to use an arrow function as a constructor
const ArrowFunction = () => {
    this.property = 'value';
};
try {
    const obj2 = new ArrowFunction();
} catch (e) {
    console.log(e.message); // TypeError: ArrowFunction is not a constructor
}




//////// NOTE THAT ARROW FUNCTIONS handle the 'arguments' object different than traditional functions. 

// -- in a traditional function(one declared using the keyword 'function'), you have access to an 'arguemnts' object. This is an array like object that contains all of the arguments
function traditionalFunction() {
    console.log(arguments);
}
traditionalFunction(1, 2, 3); // Output: [1, 2, 3]

/////ARROW FUNCTIONS do not provide their own 'arguemnts' object. If you try to access 'arguments' inside an arrow function, it will take the value from the global or local scope 
//- NOTE that if you need to work with a variable number of arguments in an arrow function, you should use rest parameters instead:
const arrowFunction = () => {
    console.log(arguments);
}
arrowFunction(1, 2, 3); // This will throw a ReferenceError or log the `arguments` from a higher scope, if any



const arrowFunctionWithRest = (...args) => {
    console.log(args);
}
arrowFunctionWithRest(1, 2, 3); // Output: [1, 2, 3]


//SUMMARY: -traditional functions have access to an 'arguemnts object' reflecting the parameters passed to them
//         - arrow functions do not have this feature^^. Arrow functions should use rest parameters (...args) to handle an arbitrary # of arguments




















//////////////ALTERNATIVE DEFAULT PARAMETERS
//sometimes it makes sense to assign default value for parameters at a later stage after the function declaration. We can check if the parameter is passed using 'undefined'
function showMessage(text) {
  // ...
  if (text === undefined) { // if the parameter is missing
    text = 'empty message';
  }
  alert(text);
}
showMessage(); // empty message

//----OR we could use the OR operator:
function showMessage(text) {
  //if text is undefined or otherwise falsy, set it to 'empty'
  text = text || 'empty';
  ...
}




/////MODERN DAY JS AND SUPPORTING 'nullish coalescing operator'
function showCount(count) {
  // if count is undefined or null, show "unknown"
  alert(count ?? "unknown");
}

showCount(0); // 0
showCount(null); // unknown
showCount(); // unknown



/////-----NULLISH COALESCING OPERATOR. written as ??
/* 
the result of 'a ?? b' is:
-if 'a' is defined(not 'null' or 'undefined'), then 'a'
- if 'a' is null or undefined, then 'b'

in other words, ?? returns the first argument if it's not null/undefined. Otherwise, it returns the second one.
-The nullish coalescing operator isn't anything completely new. It's just a nice syntax to get the first "defined" value of the two. 

we can then rewrite 'result = a ?? b' using operators we already know: */
result = (a !== null && a !== undefined) ? a : b;
// remember that ? and : are used as ternary operators. (if not a, then b "? a : b" )

// The common use case for '??' is to provide a default value.
let user;
alert(user ?? "Anonymous"); 
// will return Anonymous becuase user is not defined above it. 
let user = "John";
alert(user ?? "Anonymous");
//will return 'John' becuase it is defined. (if not A, then B)(if user is undefined, then(??) write anonymous)


// we can also use a sequence of ?? to select the first value from a list that isn't 'null/undefined'
let firstName = null;
let lastName = null;
let nickName = "Supercoder";

alert(firstName ?? lastName ?? nickName ?? "Anonymous");
// notice that two of variables are not defined(maybe the user did not put them in). 
// We would like to display the user name using one of these variables, or show "Anonymous" if all are undefined. so we use ?? to select the first defined value




//---- The 'or' || operator can be used in the same way as ??
let firstName = null;
let lastName = null;
let nickName = "Supercoder";
// shows the first truthy value:
alert(firstName || lastName || nickName || "Anonymous"); // will return "Supercoder"

/*NOTE: the 'or' || operator has been around since the start of js. but ?? was made becuase people were not happy with ||.
-   || returns the first 'truthy' value
-   ?? returns the first 'defined' value

- || does NOT distinguish between false, 0, an empty string, "", and null/undefined. They are all 'falsy' values to ||
*/
// we may want to use default value only when the variable is null/defined. That is, when the value is really unknown/not set
let height = 0;

alert(height || 100); //will return 100 
alert(height ?? 100); // will return 0
// notice that because the height(even though it was defined) is set to 0. || reads that as 'falsy' and alerts you then "or" option.(100)


// the PRECEDENCE of the ?? operator is the same as ||. They both equal to 3 in MDN table. 
// This means that, just like ||, the ??(nullish coalescing operator) is evaluated before = and ? but after most other operations like * +
// so we might have to add parentheses in expressions like this. 
let height = null;
let width = null;
// important: use parentheses
let area = (height ?? 100) * (width ?? 50);
alert(area); // 5000

//if we omit the parentheses, then as * would have higher precedence than ??, it would execute first, leading to incorrect results.
let area = height ?? 100 * width ?? 50;
//another example:
let area = height ?? (100 * width) ?? 50; 
//the above would work but it would not give us the answer we want.



//----USING ?? with && or ||
// JAVASCRIPT FORBIDS!!! using ?? together with && and ||, unless the precedence is explicitly specifeied with parentheses
let x = 1 && 2 ?? 3; // will return syntax error

let x = (1 && 2) ?? 3;
alert(x);// will return 2



/////// SUMMARY ON ??
/*
---- the nullish coalescing operator, ??, provides a short way to choose the first 'defined' value from a list. 
- it is used to assign default values to variables.
--this operator has a low precedence( a bit higher than ? and =), so use parentheses when using it in an expresssion.
*/








////////// RETURNING A VALUE
// --- A function can return a value back into the calling code as the result. 
function sum(a, b) {
  return a + b;
}
let result = sum(1, 2);
alert( result ); // 3

// the return can be in any place of the function. // there can be many occurances of 'return' in a single function:
function checkAge(age) {
  if (age >= 18) {
    return true;
  } else {
    return confirm('Do you have permission from your parents?');
  }
}
let age = prompt('How old are you?', 18);
if ( checkAge(age) ) {
  alert( 'Access granted' );
} else {
  alert( 'Access denied' );
}


// It is possible to use 'return' without a value. That causes the function to immediately exit.
function showMovie(age) {
  if ( !checkAge(age) ) { //translation: if checkAge() returns 'falsy',
    return; // then showMovie won't proceed to the alert.
  }
  alert( "Showing you the movie" ); // (*)
  // ...
}



/*  NOTE That a function with an empty 'return' or without it returns 'undefined'
- If a function does not return a value, it is the same as if it returns 'undefined' */
function doNothing() {
   /* empty */
}
alert( doNothing() === undefined ); // will return true

// AN EMPTY RETURN IS THE SAME AS 'return undefined'
function doNothing() {
  return;
}
alert( doNothing() === undefined ); // will return true



// NEVER ADD A NEW LINE BETWEEN 'return' and the value
//-----for a long expression in return, it might be tempting to put it on a separate line. DO NOT DO THAT. JS assumes a semicolon after 'return'
//- start the expression on the same line as the return or add opening parentheses:
return (
  some + long + expression 
  + or +
  whatever * f(a) + f(b)
)





////////NAMING A FUNCTION
//----a function is an action so their name is usually a verb. It should be brief, as accurate as possible and describe what the function does.
//-- It is a widespread practice to start a function with a prefix that describes the action
showMessage(..) //the 'show' prefix is used to show something
getExample(..) // 'get' prefix returns the example
calcSum(..) //calculates something (in this case, a sum)
createForm(..) //creates (and usually returns) a form.
checkPermission(..) // checks a permissions, returns true/false

////// THERE ARE SOME VERY SHORT FUNCTIONS THAT ARE USED OFTEN
// the jQuery frame work defines a function with $



///////////    FUNCTIONS == COMMENTS
// ---- If you have a big, long function, it might be easier and should be practiced splitting up the 1 big function into a few smaller ones.
function showPrimes(n) {
  nextPrime: for (let i = 2; i < n; i++) {

    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert( i ); // a prime
  }
}
// ABOVE: uses a label 
// while BELOW uses an additional function 'isPrime(n)' to test for primality:
function showPrimes(n) {
for (let i = 2; i < n; i++) {
  if (!isPrime(i)) continue;
  alert(i);  // a prime
}
}
function isPrime(n) {
for (let i = 2; i < n; i++) {
  if ( n % i == 0) return false;
}
return true;
}




////////// SUMMARY ON FUNCTIONS:
// a function declaration:
function name(parameters, delimited, by, comma) {
  //code goes here
}
// - values passed to a function as parameters are copied to its local variables. 
// - a function may access outer variables. But it works only from inside out. 
// - a function can return a value. If it doesn't, then the result in 'undefined'
// - names should be easy to understand and clearly describe what the function does. 












//////////// JAVASCRIPT CALL STACK
//--Call Stack keeps track of all the functions and all of its place in a code that calls multiple functions. The JS engine uses a call stack to manage 'execution contexts'
//-the global execution context
//-Function execution context

/*
NOTE THAT THE CALL STACK WORKS BASED ON THE " LAST-IN-FIRST-OUT "(LIFO) PRINCIPAL.

- When you execute a script, the JavaScript engine creates a global execution context for the funciton, pushes it on top of the call stack, 
      and starts executing the function

-If a function calls another function, the JS engine creates a new function execution context for the function being called,
      and pushes it on top of the call stack.

- When the current function completes, the JS engine pops it off the call stack and resumes the execution where it left off.
      The script will stop when then call stack is empty.  */
function add(a, b) {
  return a + b;
}

function average(a, b) {
  add(a,b) / 2
}

let x = average(10,20);
//When the JS engine executes this script, it places the global execution context(dennoted by main() or global()) function on the call stack.
 __________
|          |
|Call Stack|
|          | 
|          | 
| -------- | 
|  Main()  |
| -------- |
|__________|
//-The global execution context enters the creation phase and moves to the execution phase.
//- The JS engine executes the call to 'average(10,20) function and creates a funciton execution context for the 'average()' function and pushes it on top of the call stack
 __________
|          |
|Call Stack|
|          | 
|          |
| -------- |
| average()|
| -------- | 
| -------- | 
|  Main()  |
| -------- |
|__________|
// The JS engine starts executing the average() since becuase the average() function is on top of the call stack.
//The average() function calls add() function. So the JS engine creates another function execution context for add() and places it on top of the call stack.
 __________
|          |
|Call Stack|
|          | 
|          |
| -------- |
|   add()  |
| -------- |
| -------- |
| average()|
| -------- | 
| -------- | 
|  Main()  |
| -------- |
|__________|
// The JS engine executes the add() function and pops it off the call stack. 
 __________
|          |
|Call Stack|
|          | 
|          |
| -------- |
| average()|
| -------- | 
| -------- | 
|  Main()  |
| -------- |
|__________|
// Now the average() is on top so the engine executes average() and pops it off the stack
 __________
|          |
|Call Stack|
|          | 
|          | 
| -------- | 
|  Main()  |
| -------- |
|__________|
//Nos the stack is considered empty so the script stops executing
 __________
|          |
|Call Stack|
|          | 
|          | 
|          | 
|          |
|          |
|__________|




/////// WE ALSO HAVE STACK OVERFLOW.
//----The call stack has a fixed size, depending on the implementation of the host environment, either the web browser or Node.js
//-- If the number of execution contexts exceeds the size of the stack, a stack overflow error will occur.

// FOR EXAMPLE: when you execute a 'recursive function' that has no exit condition, the JS engine will issue a stack overflow error!
function fn() {
  fn();
}
fn(); //stack overflow



/////// WE ALSO HAVE " Asynchronous JavaScipt"
//---- JS is a single-threaded programming language. This means that the JS engine has only one call stack. Therefore, it only can do one thing at a time.
//-- When executing a script, the JS engine executes code from top to bottom, line by line. In other words, it is 'synchronous'
// - Asynchronous means that the JS engine uses an 'event loop', which will be covered in the following tutorial.

/////SUMMARY :
//--- JS engine uses a call stack to manage execution contexts.
//--- The call stack uses the stack data structure that works based on the LIFO(last-in-first-out) principal.
















///////THE MODULO OPERATOR %
function isOdd(n) {
  return n % 2 !==0;
}
//above is an expression that checks if a number(n) is odd using the modulo (%) operator. 
//-- In this function, 'n % 2' computes the remainder of 'n' divided by 2. For odd numbers, this remainder is always 1(or any non-zero for odd numbers greater than 1)
// - and for even numbers, its always 0. So, the expression 'n % 2 !== 0' returns 'true' if 'n' is odd and 'false' if it is even. 






















////////////////////////////////////////////////////////////NEXT ODIN CHAPTER:///////////////////////////////////////////////////////////
PROBLEM SOLVING!
/* "Problem solving is writing an original program that preforms a particular set of tasks and meets all stated constraints" -Think like a Programmer - V. Anton Spraul
   3 bullet points to know by the end :
--- The 3 steps in the problem solving process and how to explain them
-- Pseudocode: What it is, and how to use it to solve problems. 
- How to break down problems into subproblems.



// -- UNDERSTAND THE PROBLEM!
// understand the problem enough to be able to explain the problem to someone else.

// -- PLAN!
   Ask yourself:
 - does your program have a user interface? what will it look like? what functionality will the interface have?
 - What inputs will your program have? Will the user enter data or will you get input from somewhere else.
 - What is the desired output?
 - Given your inputs, what are the steps necessary to return the desired output?

 // NOTE that the last question is where you will write an algorithm to solve the problem.






////// PSEUDOCODE!!!
// Psuedocode is writing out the logic for your program in natural language instead of code:::::
When the user inputs a number
Initialize a counter varialbe and set its value to zero
While counter is smaller than user inputted number increment the couter by one
Print the value of the counter variable

- at its core, pseudocode is the ability to represent six programming constructs (always written in uppercase):
SEQUENCE: represents linear tasks sequentially performed one after the other
WHILE: a loop condition at its beginning
REPEAT-UNTIL: a loop with a condition at the bottom
FOR: another way of looping
IF-THEN-ELSE: a conditional statement chaning the flow of the algorithm.
CASE: the generalization form of 'IF-THEN-ELSE'


HOW TO WRITE PSEUDOCODE: 
1) Always capitalize the initial word (often one of the  main constructs) 
2) Make only one statement per line
3) Indent to show hirearchy, improve readability, and show nested constructs.
4) Always end the multi-line sections using any of the END keywords (ENDIF, ENDWHILE, etc.)
5) Keep your statements programming language indpendent.
6) Use the naming domain of the problem, not that of the implementation. (for instance, "Append the last name to the first name" instead of name+first+last)
7) Keep it simple, concise, and readable.




--'SEQUENCE' constructs--
Input: Read, Obtain, Get
output: print, display, show
compute: compute, calculate, determine
initialize: set, init
add: increment, bump,
sub: decrement

--'WHILE' constructs--

 WHILE: condition
  sequence
 ENDWHILE


--'REPEAT-UNTIL' constructs--

REPEAT: sequence
UNTIL: condition


--'FOR' constructs--

FOR: iteration bounds sequence
ENDFOR


--'IF-THEN-ELSE' constructs--

IF: condition THEN
  sequence1
ELSE 
  sequence2
ENDIF


--'CASE' constructs--

CASE expression OF
condition 1: sequence 1
condition 2: sequence 2
...
condition n: sequence n
OTHERS:
default sequence
ENDCASE




// NOTE THAT THE 2 MOST NEEDED COMMANDS ARE:
1) Invoking classes or calling functions(using the CALL keyword)
2) Handling exceptions (using EXCEPTION, WHEN keywords)














BAD PSEUDOCODE EXAMPLES:
for x = 1 to 100
for y = 1 to 10
if gameBoard[x][y] = 0
  do nothing
else
  call theCall(X, Y)(recursively)
  counter += 1
   END IF
  END FOR
END FOR























////// DIVIDE AND CONQUER !
 
 -- From planning, you should have identified subproblems of the big problem to solve. 
 -- NOTE that each step from the algorithm above is an individual problem. 
 -- pick the smallest or easiest one and start there with coding

 Often times when you know the next subproblem, it gets simpler with the first solve.
 DO NOT TRY AND SOLVE THE BIG PROBLEM IN ONE GO. YOU WILL GET TIED IN KNOTS DUE TO COMPLEXITY OF CODE AND MAKE IT HARDER IN THE LONG RUN.





 ////// SOLVING FIZZ BUZZ
fizz buzz is a game where you count up and any number divisible by 3 you say 'fizz' and any number divisible by 5, you say 'buzz'... ex:
1, 2, fizz, 4, buzz, fizz, 7, 8, fizz, buzz, 11, fizz, 13, 14, fizzbuzz, 16, 17, fizz, 19, buzz, ... and so on

FizzBuzz has been used as an interview screening device for computer programmers. Writing a program to output the first 100 FizzBuzz numbers
  is a realatively trivial problem requiring little more than a loop and conditional statements. However, its value in coding interviews is to 
  analyze fundamental coding habits that may be indicative of overall coding ingenuity. 


USE FIZZBUZZ TO MAKE AN OUTLINE OF A "BIG PROBLEM"
  
UNDERSTAND THE PROBLEM:
 - Write a program that takes a user's input and prints the numbers from one to the number the user entered. 
  However, for multiples of three print 'Fizz' instead of the number and for the multiples of five print 'Buzz'. 
  For numbers which are multiples of both three and five print 'FizzBuzz'.


PLAN: (remember to ask does it have an interface? what will it look like? What inputs will it have? Will it enter data or pull data from elsewhere? Desired output?)
 - Our FizzBuzz solution will be a browser console program so no need for an interface. 
 - The only user interaction will be allowing users to enter a number.
 - The user will enter a number from a prompt box.
 - Desired output is a list of numbers from 1 to the number the user entered, but each # divisible by 3 is substitued by 'fizz'
    and each # divisible by 5 is substituted by 'buzz'. But numbers that are multiples of 3 and 5 are substituted with 'fizzbuzz'.
  

PSEUDOCODE: (What are the steps necessary to return the desired output? Algorithms for the problem.)
1: When a user inputs a number
2: Loop from 1 to the entered number
3: If the current number is divisible by 3 then print "Fizz"
4: If the current number is divisible by 5 then print "Buzz"
5: If the current number is ddivisible by both 3 and 5 then print "FizzBuzz"
6: Otherwise, print the current number



DIVIDE AND CONQUER: [implement]
- We check above at the algorithm and see that we can solve 'getting input from the user.' */
let answer = parseInt(prompt("Please enter the number you would like to FizzBuzz up to:"));
// The above code should create a pop up box (prompt method) 
// and the input we get back will be stored in the variable 'answer' (let answer=)
// We also wrapped the prompt call in a parseInt() function so that a number is returned from the user's input. 


// - Now we move to the next subproblem: [Loop from 1 to the entered number]
// the 'for loop' is a very common way to do this. (in java, c++, and Ruby also)
let answer = parseInt(prompt("Please enter the number you would like to FizzBuzz up to:"));

for (let i = 1; i <= answer; i++) {    //we have seen this multiple times(declare i and assign it 1: the initial value of the variable 'i' in the group// i <= answer is the condition[loop until i is greater than the answer]// i++ incrememnts by 1.)
  console.log(i)  // as a result. if the user inputs 10, the loop would print nubmers 1-10
}


// - And we move to the next subproblem once we figured out alogrithm #2.
// algorithm #3 (if the current # is divisible by 3 then print "Fizz")
let answer = parseInt(prompt("Please enter the number you would like to FizzBuzz up to:"));

for (let i = 1; i <= answer; i++) {
  if (i % 3 === 0) { //use the modulus operator to divide the current number by 3(modulus returns the remainder of a division(so if a remainder is 0, then the number is divisible by 3))
    console.log("Fizz")
  } else {
    console.log(i);
  }
}
//note that the program now will output: 1,2, Fizz, 4, 5, Fizz, 7, 8, Fizz, 10


// NEXT SUBPROBLEM (if number is divisible by 5 then print "Buzz")
let answer = parseInt(prompt("Please enter the number you would like to FizzBuzz up to:"));

for (let i = 1; i <= answer; i++) {
  if (i % 3 === 0) {
    console.log("Fizz")
  } else if ( i % 5 === 0) {
    console.log("Buzz")
  } else {
    console.log{i};
  }
}



// Next subproblem happens to be the last one here! (If the current # is divisible by 3 and 5 then print "FizzBuzz")
let answer = parseInt(prompt("Please enter the number you would like to FizzBuzz up to:"));

for ( let i = 1; i <= answer; i++) {
  if (i % 3 === 0 && i % 5 === 0) {
    console.log("FizzBuzz");
  } else if (i % 5 === 0) {
    console.log("Fizz");
  } else if (i % 5 === 0) {
    console.log("Buzz")
  } else {
    console.log(i);
  }
}

// NOTE THAT IF YOU ADD (i % 3 === 0 && i % 5 ===0) UNDER THE PREVIOUS SUBPROBLEM, it checked that if (i % 3 === 0) and then would move on. 
// ---So we check if they both are divisible first then move onto INDIVIDUAL conditions.

// -! This program is now complete. If you run it now, you should get the output:
1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz
16
17
Fizz
19
Buzz








////// MORE THINGS TO REMEMBER ON 
PROBLEM SOLVING:


/* --- 3 things to try when facing a real big problem:
  - Debug: Go step by step through your solution trying to find out where you went wrong. 
  - Reassess: Take a step back. Look at the problem from another perspective. Is there anything that can be abstracted to a more general approach?
      *(Another way of reassessing is to start over and begin with fresh eyes.)
  - Research: Find other peoples solutions and learn what they did to fix it.
  -Caveat: Don't look for a solution to the big problem. Only look for solutions to sub-problems. Why? Becuase unless you struggle, you wont learn anything.
*/


//////////***** ABOUT COMMENTS: comments can be misused just like any other tool. Do not make it practice to have comments explaining everything you do.
// ****DO NOT COMMENT WHEN YOU SHOULD BE USING GIT!
////////!!!!!!THINGS TO ASK WHEN CREATING A VARIABLE

/* !!!! WHATS ITS NAME? 
        WHATS ITS STARTING VALUE?
        WHATS ITS TYPE?


INPUT: should never be the first line of the algorithm. 
you need to have a variable in place and a question being asked of the user    */

//CREATE AN ALGORITHM FOR A PROGRAM THAT ASKS THE USER FOR 2 NUMBERS AND ADDS THEM: (make sure algorithms are comments.)(then ONE LINE AT A TIME, write code)

// create an integer variable for x 
let x = 0;
// create an integer variable for y
let y = 0;
// create an integer variable for sum
let sum = 0;
// ask the user "X: " and put the answer in x
x = parseInt(prompt("X: "));
// ask the user "Y: " and put the answer in y
y = parseInt(prompt("Y: "));
// put x + y in sum
sum = x + y;
// tell user "answer is  " sum
alert("The sum of x + y is " + sum);





//BEST DEBUGGING TIPS
//--- the best way to debug is to not have bugs
//--- bad implementation can be googled
//--- bad algorithms cannot be googled usually
//--- what are you not understanding?
//---what tools can you use?
//--- DONT start with a solution
//--- start by truly understanding the problem














/////////////////////////////// NEXT ODIN LESSON: UNDERSTANDING ERRORS!!!!!!///////////////
//    SHOULD BE ABLES TO'S:
 // -- name at least three kinds of javascript errors.
 // -- Identify two parts of an error message that help you find where the error originiates. 
 // -- Be able to understand how to research and resolve errors.


 //////// THE ANATOMY OF AN ERROR
//- Errors are a type of object built into the JavaScript language, consisting of a name/type and a message.
// - They contain crucial information that can assist you in locating the code responsible for the error, determining why you have this error, and resolving the error.
const a = "Hello";
const b = "world";

console.log(c);
//the code will run but it will generate an error. In technical terms, this is called "throwing" and error. (The error was a "ReferenceError")
//---The first part of an error displays the type of error. This provides the first clue as to what you're dealing with.

// - a RefereneError is thrown when one refers to a variable that is not declared and/or initialized within the current scope.

//---- THE 2ND PART of the error gives us the name of the file in which you can find the error, along with a line number!   ex:(script.js:4)
// the example originates from the 4th line of script.js (when you click the error, most browsers will bring you to the code)



//////////another important part of the error is the STACK TRACE!
//- this helps you understand when the error was thrown into your application and what functions were called that led up to the error. 
const a = 5;
const b = 10;

function add() {
  return c;
}

function print() {
  add();
}

print();

// our function print() should call on add() , which returns a variable named c , which currently has not been declared. The corresponding error:
/* 
> Uncaught ReferenceError: c is not defined.
        at add (script.js:5)
        at print (script.js:9)
        at script.js:12
 
the above STACK TRACE tells us:
1) c is not defined in scope of add() , which is declared on line 5
2) add() was called by print() , which was declared on line 9
3) print() itself was called on line 12.





// ---- Most common types of errors : ---- /////

Syntax error: 
occurs when the code you are trying to run is not written correctly, i.e. in accordance with the grammatical rules of Javascript. for example:
function helloWorld() {
  console.log "Hello World!"
}

Reference error: 
occurs when you try to reference a variable that does not exist(within the current scope)


type error:
these errors are thrown for a few different reasons:
1) an operand or argument passed to a function is incompatible with the type expected by that operator or function.
2) when attempting to modify a value that cannot be changed.
3) when attempting to use a value in an inappropriate way.
[say we have two strings that you would like to combine to create one message, such as below.]   */
const str1 = "Hello";
const str2 = "World";
const message = str1.push(str2);
// TypeError: str1.push is not a function 
//        at script.js:3:22

// above we get a type error showing a message that str1.push is not a function. A common error message that confuses learners becuase .push() is a function. but not a string method, its an array method.




/////Tips for resolving errors:
/*
1) Read the error CAREFULLY and try to understand it on your own. 

2)Next step is GOOGLE THE ERROR. Find a fix or explanation on StackOverflow or in the documentation. If nothing else; you will gain more clarity as to why you get the error.

3) USE THE DEBUGGER! its great for more involved troubleshooting, and is a critical tool for a dev. Set breakpoints, 
    view the value of any variable at any point in execution, step through code line by line.

4) MAKE USE OF THE CONSOLE! console.log() is popular for quick debugging. Use the debugger when you have more involved troubleshooting.
    There are other useful methods like console.table() and console.trace() 
*/







///// ERRORS VS WARNINGS!
// ERRORS, will stop the execution of your program or whatever process you may be attempting and prevent further action.
// WARNINGS, are messages that provide insight on potential problems that may not necessarily crash the program. 
//    while you should address warnings if possible and as soon as possible, they are notas significant as errors and are more likely informational.

//warnings will be shown in yellow, while errors will be shown in red. 







//// more on errors

/*
"Uncaught TypeError: can't access property "textContent", lowOrHi is null"

Depending on the browser you are using, you might see a different message here. The message above is what Firefox will show you, 
    
but Chrome, for example, will show you this:

"Uncaught TypeError: Cannot set properties of null (setting 'textContent')"

It's the same error, but different browsers describe it in a different way.
*/





// Below is an exercise using the devtools and debugging 

//      https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/What_went_wrong












////////////////NEXT ODIN CHAPTER: GUIDELINES TO CLEAN CODE AND IMPROVING READABILITY OF CODE!!
// OVERVIEW: 
// ---- Know how to distinguish hard to read code from easy to read code.
// ---- Use programming principles to make your code cleaner
// ---- Write good comments




//// CLEAN CODE vs MESSY CODE
const x = function(z) {
  let w = 0; z.forEach(
    function (q) {
      w += q;
    }
  ); return w;
};

x([2, 2, 2]);

////// NEXT EXAMPLE:
const sumArray = function (array) {
  let sum = 0;
  array.forEach(function (number) {
    sum += number;
  });
  return sum;
};

sumArray([2, 2, 2]);

/// THE BOTTOM CODE IS MUCH CLEANER. because even if you do not know what each means, it is much easier to guess what it does mean. 
// THE TOP CODE: uses single-letter variables, a semicolon in the middle of lines, and indentation is inconsistent. 

//NOTE THAT single characters can be used as variable names in the context of a loop or callback function, but avoid them elsewhere.



/*
/////GOOD NAME EXAMPLES:
function getPlayerScore();
function getPlayerName();
function getPlayerTag();



/////// BAD NAME EXAMPLES:
function getUserScore(); 
function fetchPlayerName();
function retrievePlayer1Tag();
*/




// Good
const numberOfThings = 10;
const myName = "Thor";
const selected = true;

// Bad (these start with verbs, could be confused for functions)
const getCount = 10;
const isSelected = true;

// Good
function getCount() {
  return numberOfThings;
}

// Bad (it's a noun)
function myName() {
  return "Thor";
}







//////USE SEARCHABLE AND IMMEDIATELY UNDERSTANDABLE NAMES.
setTimeout(stopTimer, 3600000);
//obvious problem is what does 3600000 mean??? how long before executing stopTimer??? 
// Make the code more meaningful by introducing a descriptive variable:
const MILLISECONDS_PER_HOUR = 60 * 60 * 1000; //3, 600, 000;

setTimeout(stopTimer, MILLISECONDS_PER_HOUR);
//NOTE THAT CAPSLOCK WAS USED ABOVE because it is used when the programmer is ABSOLUTELY SURE that the variable is TRULY a constant. (Miliseconds will never change, therefore it is apropriate)







////////INDENTATION AND LINE LENGTH:
//---Generally, your code will be easier to read if you manually break lines that are longer than about 80 characters.
// -- When manually breaking lines, you should try to break immediately AFTER an operator or comma.

// This line is a bit too long
let reallyReallyLongLine = something + somethingElse + anotherThing + howManyTacos + oneMoreReallyLongThing;

// You could format it like this
let reallyReallyLongLine =
  something +
  somethingElse +
  anotherThing +
  howManyTacos +
  oneMoreReallyLongThing;

// Or maybe like this
   let anotherReallyReallyLongLine = something + somethingElse + anotherThing +
                                     howManyTacos + oneMoreReallyLongThing;






////////////SEMICOLONS: are mostly optional in JS because the JS compiler will automatically insert them if thy are omitted. 
//  This functionality CAN break in certain situations leading to bugs so it is better to get used to using semicolons. CONSISTENCY CONSISTENCY CONSISTENCY.






//////////***** ABOUT COMMENTS: comments can be misused just like any other tool. Do not make it practice to have comments explaining everything you do.
/// !!! DONT COMMENT WHEN YOU SHOULD BE USING GIT!!!

// example of a bad note :
/**
 * 2023-01-10: Removed unnecessary code that was causing confusion (RM)
 * 2023-03-05: Simplified the code (JP)
 * 2023-05-15: Removed functions that were causing bugs in production (LI)
 * 2023-06-22: Added a new function to combine values (JR)
 */
// GIT TRACKS ALL CHANGES FOR YOU !!!
//ALL READILY ACCESSIBLE WITH 'git log' also.

// as long as you delete comments(after the code is working) feel free to make any you find useful on the page.



///////// TELL WHY NOT HOW!
// ---- Good comments explain the reasons behind a piece of code.
// Bad Example - comment doesn't tell why, only what and how

// This function increments the value of i by 1
function incrementI(i) {
  i = i + 1; // Add one to i
  return i;
}

// Better Example - comment tells a why
// This function increments the value of index to move to the next element
function incrementI(i) {
  i = i + 1;
  return i;
}

// Good Example - the code tells all that is needed
function moveToNextElement(index) {
  index = index + 1;
  return index;
}

//This doesn’t mean good code should lack comments. In many situations, well-placed comments are priceless. 
// We don’t want you to avoid comments, just be mindful of how they are best used.

// good example:
function calculateBMI(height, weight) {
    // The formula for BMI is weight in kilograms divided by height in meters squared
  const heightInMeters = height / 100;
  const bmi = weight / (heightInMeters * heightInMeters);
  return bmi;
}







////////    10 PRINCIPLES FOR KEEPING YOUR PROGRAMMING CODE CLEAN! : /////
/*
  1) Revise your logic before coding!
    - flow diagrams and pseudocode might come in handy to verify logic behind those lines of code.

  2) Clearly expose the structure of the page!

  <div id="main-container">
    <div id="header">
        <div id="logo">...</div>
        <div id="main-menu">...</div>
    </div>
    <div id="content">
        <div id="left-column">...</div>
 
        <div id="center-column">...</div>
        <div id="right-column">...</div>
    </div>
    <div id="footer">
        <div id="footer-menu">...</div>
        <div id="disclaimer">...</div>
    </div>
</div>  

 - This structure appears evident due to the DIV containers being so concretely named after their destined content. 
 - The above goes hand-in-hand with the below. 

  3) Use the correct indentation!
    - indentation distinctly displays the opening and closing points of each element used. 

  4) Write explanatory comments!
    - Easy, fast, and straight to the point! Also very efficient considering the fact that they can be read the exact moment of doubt
    (They can be overused, which brings us to #5)

  5) Avoid Abusing Comments
    - DO NOT: write explanatory notes to yourself(//will finish later), use comments to blame others, write vague statements in comments, 
            erasing chunks of code: Sometimes people are not sure of erasing things and it's not absolutely evil to comment that code instead.

  6) Avoid Extremely Large Functions
    - break larger function into smaller functions conforming the whole aplication process if some functions repeat themselves. 

  7) Use naming standards for functions and variables
    - Name should be descriptive enough as to give a general idea of what it does or what its for. 

  8) Treat changes with caution
    - There must be an awareness of not meddling with previous efforts for maintaining the code when adding, removing, or changing something. 

  9) Avoid indiscriminate mixing of coding languages
    - In-line CSS styling and scattered JavaScript tags with short procedures withing them are very good examples of incorrect mixing of coding languages

  10) Summarize your imports
    -  It is better to have additional coding languages imported through stylesheets. But too many stylesheets gets messy can can be summarized in 1 or 2.
    - It also saves loading time as each imported file is an HTTP request that tampers with the performance of your application. 
    - Summarizing makes things more tidy and also is a huge consideration for efficiency in your program.
*/












///////// INSTALLING NODE.JS USING TERMINAL (ON MAC!) 
/* 
On macOS 10.15 and above, the default shell is now zsh. During installation, nvm will look for a .zshrc file in your user home directory. By default, this file does not exist so we need to create it.

To create the .zshrc file and start the nvm installation, run the following commands:

touch ~/.zshrc
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.5/install.sh | bash
Restart your terminal, or copy and paste the following into your terminal and press Enter:

export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh" # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion" # This loads nvm bash_completion
Test your nvm installation by running:

nvm --version
For more information, view NVM’s github documentation.

Installing Node
Now that we have nvm installed, we can install Node.

Step 1: Installation
Run:

nvm install --lts
This will install the most recent stable version of Node in ‘long-term support’ (LTS), and you’ll see a lot of output in the terminal. If everything worked, you should see something similar to this somewhere in the lines of output (with the X’s replaced with actual numbers):

Downloading and installing Node vXX.xx.x...
If not, close the terminal, re-open it and run nvm install --lts again.

Step 2: Setting the Node version
We need to tell nvm which version of Node to use when we run the node command. It’s easy; just run the following command:

nvm use --lts
We have told nvm to use the most recent LTS version of Node installed on our computer. You must use the LTS version of Node to avoid incompatibilities with packages we will be installing in future lessons. The LTS version of Node is a version that is guaranteed support for thirty months after its initial release. It is more stable and compatible with a variety of packages than a non-LTS version of Node.

Now when you run node -v, you should see vXX.xx.x or something similar (with the X’s replaced with actual numbers).

If you see that, you have successfully installed Node!

Using Node console
For convenience, Node provides an interactive console which lets you run and edit your JavaScript code right in your terminal, similar to IRB for ruby. This is quite helpful to debug or test small snippets of your code quickly without opening the browser every time.

To run the Node console, open up your terminal and type node. Type .exit to quit the console.
*/








/////////////////////////////// FUNDAMENTALS PART 4!!!! //////////////////
arrays // data structures that can store multiple values in a single variable.
// used for organizing and manipulating large amounts of data. 

loops // control structures that allow you to execute a block of code repeatedly. 
// handy for performing the same oepration on each element of an array.

Test-Driven Development // (TDD) which is the practice of writing tests for your code beofre you write the code itself. 




/////What to know by the end:
// 1) How to use arrays
// 2) How to use built-in array methods
// 3) How to use loops
// 4) get your hands dirty with TDD exercises.








//////// ARRAYS!
// Although strings and numbers are the building blocks; as your script gets more complex, we need a way to deal with large quantities. (Arrays)
const cars = ["Saab", "Volvo", "BMW"];

//the above is used to save you from naming each single variable: 
let car1 = "Saab";
let car2 = "Volvo";
let car3 = "BMW";
// takes too long and clogs up the code.


// If you want to loop through the cars to find a specific one(maybe you have 300 and not 3). Use and array!
// you can access the values by referring to an index number.
//syntax:
const array_name = [item1, item2, item3];


// note that spaces and line breaks are NOT important. a declaration can span multiple lines. :
const cars = [
  "Saab",
  "Volvo",
  "BMW"
];




// you can also creat the array and then provide the elements after:
const cars = [];
cars[0]= "Saab";
cars[1]= "Volvo";
cars[2]= "BMW";


// you can ALSO use the javascript keyword "new" to create an array.
const cars = new Array("Saab", "Volvo", "BMW");



//the two above do exactly the same thing but for simplicity, readability, and execution speed, use the array literal method. (first one)






//////////ACCESSING ARRAY ELEMENTS (by referring to the 'index number')
const cars = ["Saab", "Volvo", "BMW"];
let car = cars[0];
//array indexes always start with 0. The first element in the array is [0], the second element in the array is [1].


/////// CHANGING AN ARRAY ELEMENT
cars[0] = "Mazda";
//^^ the above statement change the value of the selected element(in this case this first element[0])



////// CONVERTING AN ARRAY TO A STRING
// ---The JS method toString() converts an array to a string of comma separated values. 
const fruits = ["Banana", "Orange", "Apple", "Mango"];
document.getElementById("demo").innerHTML = fruits.toString();



//////ACCESS THE FULL ARRAY
//-- with JS, the full array can be accessed by referring to the array name:
const cars = ["Saab", "Volvo", "BMW"];
document.getElementById("demo").innerHTML = cars;



////// ARRAYS ARE OBJECTS
// -- arrays are a special type of objects. the 'typeof' operator in JS returns "object" for arrays.
// -- arrays use numbers to access its "elements". 
const person = ["John", "Doe", 46];
person[0] //returns John

//Objects use names to access its members.
const person = {firstName:"John", lastName:"Doe", age:46};
person.firstName //returns John




///// ARRAY ELEMENTS CAN BE OBJECTS
// --JS variables can be objects, Arrays are special kinds of objects.
// - and because of this, you can have variables of different types in the same array.
// (you can have objects in an array, function in an array, and arrays in arrays)
myArray[0] = Date.now;
myArray[1] = myFunction;
myArray[2] = myCars;



/////// ARRAY PROPERTIES AND METHODS
// - the real strength of JS arrays are the built-in array peoperties and methods. 
cars.length //returns the number of elements
cars.sort() //sorts the array
//(more methods covered in the next chapter)





///////THE LENGTH PROPERTY
const fruits = ["Banana", "Orange", "Apple", "Mango"];
let length = fruits.length;
// the length property is always one more than the highest array index.



//////ACCESSSING THE FISRT ARRAY ELEMENT
let fruit = fruits[0];
// remember that [0] is the first element in an array. 
///
//
let fruit = fruits[fruits.length-1];
// the above accesses the very last array element






//////////LOOPING ARRAY ELEMENTS
// for loops loop over function code a certain number of times(depending on you). MAKE YOUR OWN VARIABLE. DOES NOT HAVE TO BE 'i'.

const fruits = ["Banana", "Orange", "Apple", "Mango"];
let fLen = fruits.length;

let text = "<ul>";
for (let i = 0; i < fLen; i++) {
  text += "<li>" + fruits[i] + "</li>";
}
text += "</ul>";


// you can also use the Array.forEach() function:
const fruits = ["Banana", "Orange", "Apple", "Mango"];

let text = "<ul>";
fruits.forEach(myFunction);
text += "</ul>";

function myFunction(value) {
  text += "<li>" + value + "</li>";
}






////////ADDING TO ARRAY ELEMENTS
// - easiest way to add a new element to an array is using the push() method:
const fruits = ["Banana", "Orange", "Apple"];
fruits.push("Lemon"); // adds the new element (lemon in this case) to the array "fruits"

// you can also use the length property:
const fruits = ["Banana", "Orange", "Apple"];
fruits[fruits.length] = "Lemon"; //adds "Lemon" to the array 'fruits'


/// **** WARNING!: adding elements with high indexes can create undefined "holes" in an array!  **** ///
const fruits = ["Banana", "Orange", "Apple"];
fruits[6] = "Lemon";  // Creates undefined "holes" in fruits







////// ASSOCIATIVE ARRAYS (are arrays with named indexes)/ also called "hashes"
// - many programming languages support arrays with name indexes. 
// - JS does NOT support arrays with named indexes.
// - In JS, arrays always use numbered indexes.
const person = [];
person[0] = "John";
person[1] = "Doe";
person[2] = 46;
person.length;    // Will return 3
person[0];        // Will return "John"

// ** !(WARNING) if you use named indexes, JS will redefine the array to an object. After that, some array methods and properties will produce INCORRECT RESULTS.
const person = [];
person["firstName"] = "John";
person["lastName"] = "Doe";
person["age"] = 46;
person.length;     // Will return 0
person[0];         // Will return undefined





/////////THE DIFFERENCE BETWEEN ARRAYS AND OBJECTS
// in JS, arrays use numbered indexes
// in JS, objects use named indexes

// You should use arrays when you want the element names to be numbers
// and on the flip, use objects when you want the element names to be strings(text)




/////// Javascript new Array() . ---- JS has a built-in array constructor 'new Array()'
// you can safely use [] instead.
const points = new Array();
const points = [];
// both the above create a new empty array named points,

const points - new Array(40, 100, 1, 5, 25, 10);
const points = [40, 100, 1, 5, 25, 10];
// both the above statements create a new array called 'points' containing 6 nubmers


//the 'new' keyword can get tricky with certain results::::

// Create an array with three elements:
const points = new Array(40, 100, 1);

// Create an array with two elements:
const points = new Array(40, 100);

// Create an array with one element ???
const points = new Array(40);  //this returns ''''''''''''''''''''''''''




///// A VERY COMMON ERROR
const points = [40];
// is NOT the same as:
const points = new Array(40);
//becuase the first one(const points = [40]) creates an array with one element(and the element's number is 40)
// the 2nd one(const points = new Array(40);) creates an array with a length of 40 and all of the elements are undefined





///////HOW TO RECOGNIZE AN ARRAY
const fruits = ["Banana", "Orange", "Apple"];
let type = typeof fruits;
// the problem with the above is that the 'typeof' operator returns "object" because a JS array is an object.

Array.isArray(fruits);
// the above is a solution to the 'typeof' problem. Running the above code returns 'true'

//the second solution is to use the 'instanceof' operator
const fruits = ["Banana", "Orange", "Apple"];
fruits instanceof Array;





//////LIST OF BASIC ARRAY METHODS:
Array .length  //Sets or returns the number of elements in an array
Array toString() //Converts an array to a string, and returns the result
Array at() //Returns an indexed element of an array
Array join() //Joins all elements of an array into a string
Array pop() //Removes the last element of an array, and returns that element
Array push() //Adds new elements to the end of an array, and returns the new length
Array shift() //Removes the first element of an array, and returns that element
Array unshift() //Adds new elements to the beginning of an array, and returns the new length
Array delete()
Array concat() //Joins arrays and returns an array with the joined arrays
Array copyWithin() //Copies array elements within the array, to and from specified positions
Array flat() //Concatenates sub-array elements
Array splice()	//Adds/Removes elements from an array. ex) fruits.splice(1, 2) would splice the 2nd and 3rd element out
Array toSpliced()
Array slice() //Selects a part of an array, and returns the new array

//////EXPANDED LIST OF ARRAY METHODS AND PROPERTIES

at()	//Returns an indexed element of an array
constructor	//Returns the function that created the Array object's prototype
copyWithin()	//Copies array elements within the array, to and from specified positions
entries()	//Returns a key/value pair Array Iteration Object
every()	//Checks if every element in an array pass a test
fill()	//Fill the elements in an array with a static value
filter()	//Creates a new array with every element in an array that pass a test
find()	//Returns the value of the first element in an array that pass a test
findIndex()	//Returns the index of the first element in an array that pass a test
findLast()	//Returns the value of the last element in an array that pass a test
findLastIndex()	//Returns the index of the last element in an array that pass a test
flatMap()	//Maps all array elements and creates a new flat array
forEach()	//Calls a function for each array element
from()	//Creates an array from an object
includes()	//Check if an array contains the specified element
indexOf()	//Search the array for an element and returns its position
isArray()	//Checks whether an object is an array
keys()	//Returns a Array Iteration Object, containing the keys of the original array
lastIndexOf()	//Search the array for an element, starting at the end, and returns its position
length	//Sets or returns the number of elements in an array
map()	//Creates a new array with the result of calling a function for each array element
new Date() // date object that returns the current date and time
of()	//Creates an array from a number of arguments
prototype	//Allows you to add properties and methods to an Array object
reduce()	//Reduce the values of an array to a single value (going left-to-right)
reduceRight()	//Reduce the values of an array to a single value (going right-to-left)
reverse()	//Reverses the order of the elements in an array
shift()	
some()	//Checks if any of the elements in an array pass a test
sort()	//Sorts the elements of an array
valueOf()	//Returns the primitive value of an array
with()	//Returns a new array with updated elements


/////note that if you push([1, 2]) for example, it will add an array to the array you added[1, 2] to. 










//////////// LOOPS!
// for of loop 
// The 'for ... of' loop is the basic tool for looping through a collection (array, set, or map)
const cats = ["Leopard", "Serval", "Jaguar", "Tiger", "Caracal", "Lion"];

for (const cat of cats) {
  console.log(cat);
}
//translation: given the collection(cats), get the first item in the collection
//   --assign it to the variable 'cat' and then run the code between the curly bracecs {}
// -- Get the next item, and repeat(2) until you've reached the end of the collection.



// JS has more specialized loops for collections
map()
//and
filter()



//////// You can use map() to do something to each item in a collection and create a new collection containing the changed items. 
function toUpper(string) {
  return string.toUpperCase();
}
const cats = ["Leopard", "Serval", "Jaguar", "Tiger", "Caracal", "Lion"];
const upperCats = cats.map(toUpper);
console.log(upperCats);   //will return [ "LEOPARD", "SERVAL", "JAGUAR", "TIGER", "CARACAL", "LION" ]
// the above passes a function into cats.map and map() calls the function once for each item in the array, passing the item.
// It then adds the return value from each function call to a new array, and finally returns it the new array. (in this case, the function we provided changed it to uppercase)


/////// you can use filter() to test each item in a collection, and create a new collection containing only items that match.
function lCat(cat) {
  return cat.startsWith("L");
}
const cats = ["Leopard", "Serval", "Jaguar", "Tiger", "Caracal", "Lion"];
const filtered = cats.filter(lCat);
console.log(filtered);  // will return [ "Leopard", "Lion" ]

// The difference with filter() to map() is that this returns a boolean value when we pass through things.

//NOTE THAT WE CAN USE AN ARROW FUNCTION TO REWRITE THIS ABOVE EXAMPLE TO BE MORE COMPACT.
const cats = ["Leopard", "Serval", "Jaguar", "Tiger", "Caracal", "Lion"];
const filtered = cats.filter((cat) => cat.startsWith("L"));
console.log(filtered);  // will return [ "Leopard", "Lion" ]




/////THE STANDARD FOR LOOP: 
for (intitializer; condition; final-expression) {
  //code to run
}
/* Above we have:
1) the keyword 'for', followed by some parentheses 

2) inside the parentheses: 
  i) an initialier- it is usually a variable set to a number, which is incremented to count the number of times the loop has run. (also called a 'counter variable')
  ii) a condition- this defines when the loop should stop looping(generally an expression featuring a comoparison operator to test if a condition is met)
  iii) a final-expression- this is always evaluated each time the loop has gone through a full iteration. Usually serves to increment (sometimes decrement)
                           the counter-variable, to bring it closer to the point where the condition is no longer 'true'

3)Some curly braces that contain a block of code - this code will be run each time the loop iterates.

*/
// NOTE that for something like the 100 random circles, you do not have a collection of items to loop through,
//      - you only want to repeat the same code 100 times. So for that, you use the 'for' loop like above.







///////CALCULATING SQUARES
const results = document.querySelector("#results");

function calculate() {
  for (let i = 1; i < 10; i++) {   // 'i' starts at 1; i++ means we add 1 to i every iteration UNTIL it is no longer '< 10'
    const newResult = `${i} x ${i} = ${i * i}`;
    results.textContent += `${newResult}\n`;
  }
  results.textContent += "\nFinished!";
}

const calculateBtn = document.querySelector("#calculate");
const clearBtn = document.querySelector("#clear");

calculateBtn.addEventListener("click", calculate);
clearBtn.addEventListener("click", () => (results.textContent = ""));
//////



// SOMETIMES WE USE THE 'FOR' LOOP TO LOOP THROUGH ARRAYS
const cats = ["Pete", "Biggles", "Jasmine"];

let myFavoriteCats = "My cats are called ";

for (const cat of cats) {
  myFavoriteCats += `${cat}, `;
}
console.log(myFavoriteCats); // "My cats are called Pete, Biggles, Jasmine, "
// obviously that sentence does not very well-formed. If we want to change it to a better sounding sentece, we need to know when we are on 
//    the final loop iteration, and to do that we can use a 'for' loop and examine the value of '1'.

const cats = ["Pete", "Biggles", "Jasmine"];

let myFavoriteCats = "My cats are called ";

for (let i = 0; i < cats.length; i++) {
  if (i === cats.length - 1) {
    // We are at the end of the array so you want a clear end of the sentence.
    myFavoriteCats += `and ${cats[i]}.`;
  } else {
    myFavoriteCats += `${cats[i]}, `;
  }
}
console.log(myFavoriteCats); // "My cats are called Pete, Biggles, and Jasmine."






/////// A LOOP THAT GOES THROUGH ALL ITEMS AND PRINTS THEM OUT ON SCREEN INSIDE LIST ITEMS
for (const item of myArray) {
        const listItem = document.createElement('li');
        listItem.textContent = item;
        list.appendChild(listItem);
      }




///////EXITING LOOPS WITH BREAK
// you can use the 'break' statement to exit a loop before the iteration completes(like in a switch statement)
const contacts = [ //created an array full of contacts
  "Chris:2232322",
  "Sarah:3453456",
  "Bill:7654322",
  "Mary:9998769",
  "Dianne:9384975",
];
const para = document.querySelector("p");
const input = document.querySelector("input");
const btn = document.querySelector("button");

btn.addEventListener("click", () => {    //attach the eventlistener to the BTN so that when its pressed, code is ran
  const searchName = input.value.toLowerCase(); //store the value of the text input into 'searchName'
  input.value = ""; // then emptying it
  input.focus(); //then focusing it again, so it is ready for the next search
  para.textContent = "";
  for (const contact of contacts) {
    const splitContact = contact.split(":"); //when inside the loop, first, we split the current contact at the colon character and store the resulting 2 values in an array 
    if (splitContact[0].toLowerCase() === searchName) { //makes the searches case-insensitive with toLowerCase() //and use a conditional statement to test whether splitContact[0] matches the search input
      para.textContent = `${splitContact[0]}'s number is ${splitContact[1]}.`; //if it does match then we return that in a sentence
      break;  //then we break to end the loop
    }
  }
  if (para.textContent === "") {  // after the loop, we check whether we set a contact, and if not,
    para.textContent = "Contact not found."; // we set the paragraph text to "Contact not found"
  }
});





////////////////BELOW WORKS WITHOUT A BUTTON (USING DIFFERENT HTML)
for (const entry of phonebook) {
        if (entry.name === name) {
          para.textContent = `Name: ${entry.name}, Phone Number: ${entry.number}`;
          break;  // exit the loop if a match is found
        }
      }





///////SKIPPING ITERATIONS WITH CONTINUE
// the 'continue' statement works similarly to 'break', but instead of exiting the iteration, it skips to the next iteration. 
const para = document.querySelector("p");
const input = document.querySelector("input");
const btn = document.querySelector("button");

btn.addEventListener("click", () => { 
  para.textContent = "Output: ";
  const num = input.value;
  input.value = "";
  input.focus();
  for (let i = 1; i <= num; i++) { //starts at 1 becuase we are not interested in 0. loop will stop when the counter becomes bigger than the input. 
    let sqRoot = Math.sqrt(i);  // finds the square root of each number
    if (Math.floor(sqRoot) !== sqRoot) {  //then check whether the square root in an interger by testing whether it is the same as itself after being rounded (Math.floor())
      continue; //if the square root and rounded down square root do not equal one another(!==), then it means we arent interested becuase its not a square root. 'continue' skips to the next iteration
    }
    para.textContent += `${i} `; //if the square root was an integer, we skip the if block entirely and 'continue' is not executed. Instead, we concatenate the current 'i' value
  }
});








//////////WHILE AND DO...WHILE

// while loop syntax:
initializer
while (condition) {
  // code to run
  final-expression
}
/* works similarly to the 'for' loop, except that the intializer variable is set before the loop, and the final-expression is included inside 
the loop after the code to run, rather than these two items being included inside the parentheses. The condition is included inside the parentheses, 
which are preceded by the 'while' keyword rather than 'for'

- The same three items are still present, and still defined in the same order as they are in the 'for' loop.
*/
// cat example rewritten using a while loop. 
const cats = ["Pete", "Biggles", "Jasmine"];
let myFavoriteCats = "My cats are called ";
let i = 0;
while (i < cats.length) {
  if (i === cats.length - 1) {
    myFavoriteCats += `and ${cats[i]}.`;
  } else {
    myFavoriteCats += `${cats[i]}, `;
  }
  i++;
}
console.log(myFavoriteCats); // "My cats are called Pete, Biggles, and Jasmine."





////do...while loop    -   is very similar but provides a variation on the while structures:
initializer
do {
  // code to run
  final-expression
} while (condition)
/* in this case, the initializer comes first again, before the loop starts. The main difference between a do...while loop and a 'while' loop
is that the code inside a do...while loop is always executed at least once. (becuase the condition comes after the code inside the loop). 
In the 'while' and 'for' loops, the check comes first, so the code might never get executed
*/



/////cat example using a do...while loop
const cats = ["Pete", "Biggles", "Jasmine"];
let myFavoriteCats = "My cats are called ";
let i = 0;
do {
  if (i === cats.length - 1) {
    myFavoriteCats += `and ${cats[i]}.`;
  } else {
    myFavoriteCats += `${cats[i]}, `;
  }
  i++;
} while (i < cats.length);
console.log(myFavoriteCats); // "My cats are called Pete, Biggles, and Jasmine."







////////LAUNCH COUNTDOWN EXERCISE
//In this exercise, we want you to print out a simple launch countdown to the output box, from 10 down to Blastoff. Specifically, we want you to:

//Loop from 10 down to 0. We've provided you with an initializer — let i = 10;.

//For each iteration, create a new paragraph and append it to the output <div>, which we've selected using const output = document.querySelector('.output');. 
//In comments, we've provided you with three code lines that need to be used somewhere inside the loop:
const para = document.createElement('p'); //creates a new paragraph.
output.appendChild(para); // appends the paragraph to the output <div>.
para.textContent = // makes the text inside the paragraph equal to whatever you put on the right-hand side, after the equals sign.
Different iteration numbers require different text to be put in the paragraph for that iteration (you'll need a conditional statement and multiple para.textContent = lines):
// If the number is 10, print "Countdown 10" to the paragraph.
// If the number is 0, print "Blast off!" to the paragraph.
//For any other number, print just the number to the paragraph.
//Remember to include an iterator! However, in this example we are counting down after each iteration,
//     not up, so you don't want i++ — how do you iterate downwards?



///// ANSWER: 
let i = 10;

while (i >= 0) {
  const para = document.createElement('p');
  if (i === 10) {
    para.textContent = 'Countdown: 10!';
  } else if (i === 0) {
    para.textContent = 'Blast off!';
  } else {
    para.textContent = `${i}`;
  }

  output.appendChild(para);

  i--;
}


// my guess. (now touched up)
for (let i = 10; i < 0; i--) {
  if (i === 10) {
    print("Countdown: 10!");
  } else if { 
    print(`${output}`) 
 } else {
    if (i === 0) {
      print("Blast Off!!!")
    }
  }
}









///////// GUEST LIST ACTIVITY:
// - write a loop that will iterate through the people array.
// - during each loop: - check if the current array item is equal to "Phil" or "Lola" using a conditional.
// - if it is, concatenate the array item to the end of teh refused paragraph's textContent, followed by a comma and a space.
// provided:
const people = ['Chris', 'Anne', 'Colin', 'Terri', 'Phil', 'Lola', 'Sam', 'Kay', 'Bruce'];

const admitted = document.querySelector('.admitted');
const refused = document.querySelector('.refused');
admitted.textContent = 'Admit: ';
refused.textContent = 'Refuse: ';

// loop starts here
for (const person of people) {
  if (person === "Phil" || person === "Lola") {
    refused.textContent += `${person}, `;
  } else {
    admitted.textContent += `${person}`;
  }
}

for (let i = 0; i < admitted.length; i++) {
  if (i = admitted.length - 1) {
    admitted += `and ${admitted[i]}`;
 }
}

for (let i = 0; i < refused.length; i++) {
  if (i = refused.length - 1) {
    admitted += `and ${refused[i]}`;
 }
}







/////////// LOOP THROUGH WITH PRIME NUMBERS 
let i = 500;
    const para = document.createElement('p');

    function isPrime(num) {
      for(let i = 2; i < num; i++) {
        if(num % i === 0) {
          return false;
        }
      }

      return true;
    }


    // Add your code here
    while (i >= 2) {
        if (isPrime(i)) {
            para.textContent += i + ', ';
        }
        i--;
    }

    para.textContent = para.textContent.slice(0, -2);

    // Don't edit the code below here!
    const section = document.querySelector('section');
    section.appendChild(para);
  </script>


//////////////////////////////////////////// syntax for loops(loop syntax/)

//for...of:
for (const item of array) {
  // code to run
}


//for:
for (initializer; condition; final-expression) {
  // code to run
}

//while:        // 'while' the condition is truthy, the code will run
initializer
while (condition) {
  // code to run
  final-expression
}


//do...while:
initializer
do {
  // code to run
  final-expression
} while (condition)







////////// ANYTHING TO REMEMBER ON LOOPS:
// for loop to ooutput even numbers (this from 2 to 10)
for (let i = 2; i <= 10; i++) {
  if (i % 2 == 0) {
    alert( i );
  }
}




/////////Skipping parts
//Any part of for can be skipped.
//For example, we can omit 'begin' if we don’t need to do anything at the loop start.
//Like here:
let i = 0; // we have i already declared and assigned
for (; i < 3; i++) { // no need for "begin"
  alert( i ); // 0, 1, 2
}
//We can also remove the step part:

let i = 0;
for (; i < 3;) {
  alert( i++ );
}
//This makes the loop identical to while (i < 3).

//We can actually remove everything, creating an infinite loop:
for (;;) {
  // repeats without limits
}

// NOTE that the two for semicolons ; must be present. Otherwise, there would be a syntax error.





//////CONTINUING THE LOOP
//The loop below uses continue to output only odd values:
for (let i = 0; i < 10; i++) {
  // if true, skip the remaining part of the body
  if (i % 2 == 0) continue;
  alert(i); // 1, then 3, 5, 7, 9
}
////EVEN VALUES
for (let i = 2; i <= 10; i++) {
  if (i % 2 == 0) {
    alert( i );
  }
}







/////BREAKING THE LOOP
//Normally, a loop exits when its condition becomes falsy.
//But we can force the exit at any time using the special break directive.
//For example, the loop below asks the user for a series of numbers, “breaking” when no number is entered:
let sum = 0;
while (true) {
  let value = +prompt("Enter a number", '');
  if (!value) break; // (*)
  sum += value;
}
alert( 'Sum: ' + sum );
//The break directive is activated at the line (*) if the user enters an empty line or cancels the input. 
//It stops the loop immediately, passing control to the first line after the loop. Namely, alert.
//The combination “infinite loop + break as needed” is great for situations when a loop’s condition must be checked not in the beginning,
//      or end of the loop, but in the middle or even in several places of its body.







///////REPLACE 'FOR' WITH 'WHILE'
let i = 0;
while (i < 3) {
  alert( `number ${i}!` );
  i++;
}





///////LABELS FOR BREAK/CONTINUE
for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
  let input = prompt(`Value at coords (${i},${j})`, '');
  // what if we want to exit from here to Done (below)?
}
}
alert('Done!');
//We need a way to stop the process if the user cancels the input.
//The ordinary break after input would only break the inner loop.

// A LABEL is an identifier with a colon before a loop:
labelName: for (...){
  ...
}


//The break <labelName> statement in the loop below breaks out to the label:
outer: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    let input = prompt(`Value at coords (${i},${j})`, '');
    // if an empty string or canceled, then break out of both loops
    if (!input) break outer; // (*)
    // do something with the value...
  }
}
alert('Done!');
//In the code above, break outer looks upwards for the label named outer and breaks out of that loop.
//So the control goes straight from (*) to alert('Done!').



//We can also move the label onto a separate line:
outer:
for (let i = 0; i < 3; i++) { ... }
// The continue directive can also be used with a label. In this case, code execution jumps to the next iteration of the labeled loop.








//////WRITE A LOOP WHICH PROMPTS FOR A NUMBER GREATER THAN 100. IF THE USER ENTERS ANOTHER NUMBER - ASK THEM TO INPUT AGAIN. 
// LOOP MUST ASK FOR A NUMBER UNTIL THE USER ENTERS ONE > 100 OR CANCELS THE INPUT/ ENTERS AN EMPTY LINE
let num;
do {
  num = prompt("Enter a number greater than 100?", 0);
} while (num <= 100 && num);
//The loop do..while repeats while both checks are truthy: !*!**!*!
//The check for num <= 100 – that is, the entered value is still not greater than 100.
//The check && num is false when num is null or an empty string. Then the while loop stops too.
//P.S. If num is null then num <= 100 is true, so without the 2nd check the loop wouldn’t stop if the user clicks CANCEL. Both checks are required.













///////////////TEST DRIVVEN DEVELOPMENT ! (TDD)
// - refers to the practice of writing automated tests that describe how your code should work BEFORE you actually write code.
// - 1 - SET UP THE TESTING ENVIRONMENT
// - 2 - READ THE SPECS
// - 3 - WRITE THE CODE THAT MAKES THEM PASS



////// USE 'NPM TEST' inside the terminal to test functions and see exactly what went wrong and what the terminal expected to see.


//
// takes two parameters and repeats the given word the specified number of times. 

const repeatString = function (word, times) { 
  if (times < 0) return "ERROR"; // translation: if the number of times is less than 0. return "error"
  let string = ""; //initialize an empty string to store the repeated word
  for (let i = 0; i < times; i++) { // for loop to concatenate the 'word' to the 'string' 'times' the number of times
    string += word;
  }
  return string; //return the resulting string
};
module.exports = repeatString;  // exports the function for testing





////////WRITE A FUNCTION THAT TAKES A STRING AND RETURNS IT BUT REVERSED.
const reverseString = function(string) {
    return string.split("").reverse().join("");
};


////// IMPLEMENT A FUNCTION THAT TAKES AN ARRAY AND SOME OTHER ARGUMENTS THEN REMOVES THE OTHER ARGUMENTS FROM THAT ARRAY
// we have 2 solutions here, an easier one and a more advanced one.
// The easiest way to get an array of the rest of the arguments that are passed to a function
// is using the rest operator. If this is unfamiliar to you look it up!
const removeFromArray = function (array, ...args) {
  // create a new empty array
  const newArray = [];
  // use forEach to go through the array
  array.forEach((item) => {
    // push every element into the new array
    // UNLESS it is included in the function arguments
    // so we create a new array with every item, except those that should be removed
    if (!args.includes(item)) {
      newArray.push(item);
    }
  });
  // and return that array
  return newArray;
};

// A simpler, but more advanced way to do it is to use the 'filter' function,
// which basically does what we did with the forEach above.

// var removeFromArray = function(array, ...args) {
//   return array.filter(val => !args.includes(val))
// }
//

module.exports = removeFromArray;





/////////// function that takes an array and some other arguments then removes the other arguemnts from that array. 
///we have 2 solutions here, an easier one and a more advanced one.
// The easiest way to get an array of the rest of the arguments that are passed to a function
// is using the rest operator. If this is unfamiliar to you look it up!
const removeFromArray = function (array, ...args) {
  // create a new empty array
  const newArray = [];
  // use forEach to go through the array
  array.forEach((item) => {
    // push every element into the new array
    // UNLESS it is included in the function arguments
    // so we create a new array with every item, except those that should be removed
    if (!args.includes(item)) {
      newArray.push(item);
    }
  });
  // and return that array
  return newArray;
};
// A simpler, but more advanced way to do it is to use the 'filter' function,
// which basically does what we did with the forEach above.
var removeFromArray = function(array, ...args) {
  return array.filter(val => !args.includes(val))
}


module.exports = removeFromArray;






//////IMPLEMENT A FUNCTION THAT TAKES 2 INTEGERS AND RETURNS THE SUM OF EVERY NUMBER (AND INCLUDING) THEM
const sumAll = function (min, max) {
  if (!Number.isInteger(min) || !Number.isInteger(max)) return "ERROR";
  if (min < 0 || max < 0) return "ERROR";
  if (min > max) {
    const temp = min;
    min = max;
    max = temp;
  }
  // An alternative way to swap the values of min and max like above is to use the array destructuring syntax.
  // Here's an optional article on it: https://www.freecodecamp.org/news/array-destructuring-in-es6-30e398f21d10/
  // if (min > max) [min, max] = [max, min];
  let sum = 0;
  for (let i = min; i <= max; i++) {
    sum += i;
  }
  return sum;
};
module.exports = sumAll;








/////Create a function that determines whether or not a given year is a leap year. Leap years are determined by the following rules:
// Leap years are years divisible by four (like 1984 and 2004). 
// However, years divisible by 100 are not leap years (such as 1800 and 1900) 
// UNLESS they are divisible by 400 (like 1600 and 2000, which were in fact leap years). (Yes, it's all pretty confusing)
const leapYears = function() {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
};

// Do not edit below this line
module.exports = leapYears;








///// Write two functions that convert temperatures form Fahrenheit to Celsiuis and vice versa
const convertToCelsius = function (fahrenheit) {
  return Math.round((fahrenheit - 32) * (5 / 9) * 10) / 10;
};

const convertToFahrenheit = function (celsius) {
  return Math.round(((celsius * 9) / 5 + 32) * 10) / 10;
};

module.exports = {
  convertToCelsius,
  convertToFahrenheit,
};









////////////  create a calculator that does the following:
// add, subtract, get the sum, multiply, get the power, 
// and find the factorial
const add = function (a, b) {
  return a + b;
};

const subtract = function (a, b) {
  return a - b;
};

const sum = function (array) {
  return array.reduce((total, current) => total + current, 0);
};

const multiply = function (array) {
  return array.reduce((product, current) => product * current)
};

const power = function (a, b) {
  return Math.pow(a, b);
};

const factorial = function (n) {
  if (n === 0) return 1;
  let product = 1;
  for (let i = n; i > 0; i--) {
    product *= i;
  }
  return product;
};

// This is another implementation of Factorial that uses recursion
// THANKS to @ThirtyThreeB!
const recursiveFactorial = function (n) {
  if (n === 0) {
    return 1;
  }
  return n * recursiveFactorial(n - 1);
};

module.exports = {
  add,
  subtract,
  sum,
  multiply,
  power,
  factorial,
};







///palindrome 
const palindromes = function (string) {
  const processedString = string.toLowerCase().replace(/[^a-z0-9]/g, "");
  return processedString.split("").reverse().join("") == processedString;
};




//// fibonaci
const fibonacci = function(countArg) {
    // checks argument's type and makes sure we use 
    // a number throughout rest of function.
    let count
    if (typeof countArg !== 'number') {
        count = parseInt(countArg)
    } else {
        count = countArg
    }

    if (count < 0) return "OOPS";
    if (count == 0) return 0;

    let firstPrev = 1;
    let secondPrev = 0;

    for (let i = 2; i <= count; i++) {
        let current = firstPrev + secondPrev;
        secondPrev = firstPrev;
        firstPrev = current;
    }

    return firstPrev;

};

// Another way to do it is by using an iterative approach with an array containing two values, 0 and 1.
// const fib = [0, 1];
// for (let i = 2; i <= count; i++) {
//    fib[i] = fib[i - 1] + fib[i - 2];
// }
// return fib[count];

module.exports = fibonacci;







////// create a function that takes the array and reutrns an array of titles.

/*```javascript
const books = [
  {
    title: 'Book',
    author: 'Name'
  },
  {
    title: 'Book2',
    author: 'Name2'
  }
]
*/
const getTheTitles = function (array) {
    return array.map((book) => book.title);
  };
  
  module.exports = getTheTitles;
  






  ////// Given an array of objects representing people with a birth and death year, return the oldest person.
  const findTheOldest = function (array) {
  return array.reduce((oldest, currentPerson) => {
    const oldestAge = getAge(oldest.yearOfBirth, oldest.yearOfDeath);
    const currentAge = getAge(
      currentPerson.yearOfBirth,
      currentPerson.yearOfDeath
    );
    return oldestAge < currentAge ? currentPerson : oldest;
  });
};

const getAge = function (birth, death) {
  if (!death) {
    death = new Date().getFullYear();
  }
  return death - birth;
};

module.exports = findTheOldest;







/////////////////////////////////
/////////////////////////////////
/////// DOM MANIPULATION AND EVENTS


// DOM module is like a tree. Parents, and branches off of them to "children"

/// Use "selectors" when working with the DOM to target nodes you want to work with. 
// - use CSS selectors to target specific nodes that you want.
// say we have this example:
<div id="container">
  <div class="display"></div>
  <div class="controls"></div>
</div>
//you can use the following to refer to <div class = "display"></div>....all of these below are selectors
div.display
.display
#container > .display
div#container > div.display





//////// Query Selectors
element.querySelector(selector)///- returns a reference to the first match of selector.
element.querySelectorAll(selectors) ///- returns a “nodelist” containing references to all of the matches of the selectors.




// when using querySelectorAll, the return value is not an array. It looks like an array, and it somewhat acts like an array, 
// but it’s really a “nodelist”. The big distinction is that several array methods are missing from nodelists
/// to convert the nodelist into an array
Array.from() // IS A METHOD IN JS THAT CREATES A NEW ARRAY INSTANCE FROM AN ARRAY-LIKE OR ITERABLE OBJECT.

// Example 1: Creating an array from a string
let str = "Hello, World!";
let charArray = Array.from(str);
console.log(charArray);
// Output: [ 'H', 'e', 'l', 'l', 'o', ',', ' ', 'W', 'o', 'r', 'l', 'd', '!' ]

// Example 2: Creating an array with a mapping function
let numbers = [1, 2, 3, 4, 5];
let squaredArray = Array.from(numbers, x => x * x); // 'numbers' is the array that you want to create a new array from./ 
// x => x * x: This is an arrow function, also known as a mapping function or a callback function. It takes an argument x (representing each element of the numbers array) and returns the square of x (x * x).
console.log(squaredArray);
// Output: [1, 4, 9, 16, 25]




////////you can also use the 'spread' operator
myFunction(a, ...iterableObj, b)
[1, ...iterableObj, '4', 'five', 6]
{ ...obj, key: 'value' }
//  - Spread syntax can be used when all elements from an object or array need to be included in a new array or object, 
//    or should be applied one-by-one in a function call's arguments list. There are three distinct places that accept the spread syntax:
Function arguments list (myFunction(a, ...iterableObj, b))
Array literals ([1, ...iterableObj, '4', 'five', 6])
Object literals ({ ...obj, key: 'value' })






//////
///// Element Creation
document.createElement(tagName, [options])
 // creates a new element of tag type tagName. [options] in this case means you can add some optional parameters to the function. 
 

 /////You can place the element into the DOM with one of the following methods.
 //append: 
parentNode.appendChild(childNode)  // - appends childNode as the last child of parentNode.
parentNode.insertBefore(newNode, referenceNode) // - inserts newNode into parentNode before referenceNode.
 //remove elements
parentNode.removeChild(child) // - removes child from parentNode on the DOM and returns a reference to child.



//// ALTERING ELEMENTS
// - When you have a reference to an element, you can use that reference to alter the element’s own properties. 
//    This allows you to do many useful alterations, like adding/removing and altering attributes, changing classes, adding inline style information and more.
const div = document.createElement('div');                     
// creates a new div referenced in the variable 'div'

//add css style
div.style.color = 'blue';                                      
// adds the indicated style rule

div.style.cssText = 'color: blue; background: white;';          
// adds several style rules

div.setAttribute('style', 'color: blue; background: white;');    
// adds several style rules




///// EDITING ELEMENTS 
div.setAttribute('id', 'theDiv');                              
// if id exists, update it to 'theDiv', else create an id
// with value "theDiv"

div.getAttribute('id');                                        
// returns value of specified attribute, in this case
// "theDiv"

div.removeAttribute('id');                                     
// removes specified attribute

// more available attributes at https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes








/////// WORKING WITH CLASSES is often standard(and cleaner) to toggle a CSS style rather than adding and removing inline CSS.
div.classList.add('new');                                      
// adds class "new" to your new div

div.classList.remove('new');                                   
// removes "new" class from div

div.classList.toggle('active');                                
// if div doesn't have class "active" then add it, or if
// it does, then remove it



// adding text content
div.textContent = 'Hello World!'                               
// creates a text node containing "Hello World!" and
// inserts it in div


// adding HTML content
div.innerHTML = '<span>Hello World!</span>';                   
// renders the HTML inside div

////// NOTE THAT textContent IS PREFERRED FOR ADDING TEXT BUT innerHTML SHOULD BE USED SPARINGLY DUE TO THE SECURITY RISK IT ADDS.

const container = document.querySelector('#container');
      const content = document.createElement('div');

      content.classList.add('content');
      content.textContent = 'This is the glorious text-content!';
      container.appendChild(content);

      const redPara = document.createElement('p');
      redPara.textContent = 'Hey I am red!';
      redPara.style.color = "red";
      container.appendChild(redPara);

      const blueHeaderThree = document.createElement('h3');
      blueHeaderThree.textContent = "I am a blue h3!";
      blueHeaderThree.style.color = "blue";
      container.appendChild(blueHeaderThree);

      const pinkAndBlack = document.createElement('div');
      pinkAndBlack.style.border = "1px solid black";
      pinkAndBlack.style.backgroundColor = "pink";

      const heading = document.createElement('h1');
      heading.textContent = 'I am in a div!';
      const paraOne = document.createElement('p');
      paraOne.textContent = 'ME TOO!';

      pinkAndBlack.appendChild(heading);
      pinkAndBlack.appendChild(paraOne);
      container.appendChild(pinkAndBlack);









//////////// EVENTS IN THE DOM
// - EVENTS are actions that occur on your webpage such as mouse-clikcs or keypresses 
//      and using JS we can make our page listen and react.   There are 3 primary ways to go about this
// 1) specify function attributes directly on your HTML elements
// 2) set properties of form on[eventType] (onclick, onmousedown, etc.) on the DOM nodes in your JS
// 3) attach event listeners to the DOM nodes in your JS. 


// METHOD 1:
<button onclick="alert('Hello World')">Click Me</button>
// NOTE that this is less than ideal because it is cluttering the HTML with JS. 
// ALSO you can now only set one 'onclick' property per DOM element, 
//   so we are unable to run mulitple separate functions in ressponse to a click event using this method.



// METHOD 2:
/*  the HTML file  */
<button id="btn">Click Me</button>
// the JavaScript file
const btn = document.querySelector('#btn');
btn.onclick = () => alert("Hello World");
// Though this is better becuase the JS is moved into the JS file, but the DOM element can still only hold 1 'onclick' property



// METHOD 3:
// the HTML file
<button id="btn">Click Me Too</button>
// the JavaScript file:
const btn = document.querySelector('#btn');
btn.addEventListener('click', () => {
  alert("Hello World");
});
// NOW we maintain separation of concerns, and we also allow multiple event listeners if the need arises.
// This method is much more flexible and powerful, though it is a bit more complex to set up


////// NOTE THAT ALL 3 OF THESE METHODS CAN BE USED WITH NAMED FUNCTIONS:
// <!-- the HTML file -->
// <!-- METHOD 1 -->
<button onclick="alertFunction()">CLICK ME BABY</button>
// the JavaScript file 
// METHOD 1
function alertFunction() {
  alert("YAY! YOU DID IT!");
}

// <!-- the HTML file -->
// <!-- METHODS 2 & 3 -->
<button id="btn">CLICK ME BABY</button>
// the JavaScript file 
// METHODS 2 & 3
function alertFunction() {
  alert("YAY! YOU DID IT!");
}
const btn = document.querySelector('#btn')
// METHOD 2
btn.onclick = alertFunction;
// METHOD 3
btn.addEventListener('click', alertFunction);
// Using named functions can clean up your code considerably, and is a really good idea 
//      if the function is something that you are going to want to do in multiple places.




// With all three methods we can access more information about the event by 
//                passing a parameter to the function that we are calling.
btn.addEventListener('click', function (e) {
  console.log(e);
});


///// MORE "TRY THIS":
btn.addEventListener('click', function (e) {
  console.log(e.target);
});


btn.addEventListener('click', function (e) {
  e.target.style.background = 'blue';
});






//////// ATTACHING LISTENERS TO GROUPS OF NODES





















///////////////HTML AND JS IN THE HEAD///// METADATA


///// REMEMBER THAT Your JavaScript, for the most part, is run whenever the JS file is run, or when the script tag is encountered in the HTML. 
//  - If you are including your JavaScript at the top of your file, many of these DOM manipulation methods will not work 
//  - because the JS code is being run before the nodes are created in the DOM. The simplest way to fix this is to include your 
//  - JavaScript at the bottom of your HTML file so that it gets run after the DOM nodes are parsed and created.




//   Alternatively, you can link the JavaScript file in the <head> of your HTML document. 
  //  - Use the <script> tag with the src attribute containing the path to the JS file, 
  //  - and include the defer keyword to load the file after the HTML is parsed, as such:
<head>
  <script src="js-file.js" defer></script>
</head>
























////////////WASP NOTES
//syntax:

route RootRoute { path: "/", to: MainPage }
page MainPage {
  // We specify that the React implementation of the page is the default export
  // of `src/client/MainPage.jsx`. This statement uses standard JS import syntax.
  // Use `@client` to reference files inside the `src/client` folder.
  component: import Main from "@client/MainPage.jsx"
}

// ex:
route HelloRoute { path: "/hello/:name", to: HelloPage }
page HelloPage {
  component: import Hello from "@client/HelloPage.jsx"
}


// ex2:
const HelloPage = (props) => {
  return <div>Here's {props.match.params.name}!</div>
}
export default HelloPage






///////// define a task entitiy in the wasp file
//Wasp uses Prisma as a way to talk to the database. You define entities by defining Prisma models using the Prisma Schema Language (PSL)
// between the {=psl psl=} tags.

// ...
entity Task {=psl
    id          Int     @id @default(autoincrement())
    description String
    isDone      Boolean @default(false)
psl=}



////we need to add a query declaration to 'main.wasp' so that Wasp knows it exists:
// ...

query getTasks {
  // Specifies where the implementation for the query function is.
  // Use `@server` to import files inside the `src/server` folder.
  fn: import { getTasks } from "@server/queries.js",
  // Tell Wasp that this query reads from the `Task` entity. By doing this, Wasp
  // will automatically update the results of this query when tasks are modified.
  entities: [Task]
}

// then create a new file and define the JS funtion we just imported in our query declaration (above):
export const getTasks = async (args, context) => {
  return context.entities.Task.findMany({
    orderBy: { id: 'asc' },
  })
}
// Query function parameters:
// args: 'object', arguments the query is given by the caller.
// context: 'object', information provided by Wasp.






////////CREATING ACTIONS
// first must declare the action in main.wasp
// ...
action createTask {
  fn: import { createTask } from "@server/actions.js",
  entities: [Task]
}


///////IMPLEMENTING ACTION
// now define a JS function for the 'createTask' action
export const createTask = async (args, context) => {
  return context.entities.Task.create({
    data: { description: args.description },
  })
}


////// INVOKING THE ACTION ON THE CLIENT
import getTasks from '@wasp/queries/getTasks'
import createTask from '@wasp/actions/createTask'
import { useQuery } from '@wasp/queries'

// ...

const NewTaskForm = () => {
  const handleSubmit = async (event) => {
    event.preventDefault()
    try {
      const target = event.target
      const description = target.description.value
      target.reset()
      await createTask({ description })
    } catch (err) {
      window.alert('Error: ' + err.message)
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input name="description" type="text" defaultValue="" />
      <input type="submit" value="Create task" />
    </form>
  )
}


// Unlike queries, you call actions directly (i.e., without wrapping it with a hook) because we don't need reactivity. 
// The rest is just regular React code.
// Now, we just need to add this form to the page component




//////ACTION TO MARK A TASK AS DONE
// main.wasp:
action updateTask {
  fn: import { updateTask } from "@server/actions.js",
  entities: [Task]
}


//implementation on server:
export const updateTask = async ({ id, isDone }, context) => {
  return context.entities.Task.update({
    where: { id },
    data: {
      isDone: isDone,
    },
  })
}


/////and now we can call updateTask from the react component:
import updateTask from '@wasp/actions/updateTask'

// ...

const Task = ({ task }) => {
  const handleIsDoneChange = async (event) => {
    try {
      await updateTask({
        id: task.id,
        isDone: event.target.checked,
      })
    } catch (error) {
      window.alert('Error while updating task: ' + error.message)
    }
  }

  return (
    <div>
      <input
        type="checkbox"
        id={String(task.id)}
        checked={task.isDone}
        onChange={handleIsDoneChange}
      />
      {task.description}
    </div>
  )
}






///////////ADDING AUTHENTICATION
////CREATING A USER ENTITIY
//Since Wasp manages authentication, it expects certain fields to exist on the User entity. 
// Specifically, it expects a unique username field and a password field, both of which should be strings.
entity User {=psl
    id       Int    @id @default(autoincrement())
    username String @unique
    password String
psl=}

// REMEMBER ! UPDATE THE DATABASE SCHEMA:
wasp db migrate-dev //in the terminal 



//// next we tell Wasp that we want to use full-stack authentication in our app:
app TodoApp {
  wasp: {
    version: "^0.11.0"
  },
  title: "Todo app",

  auth: {
    // Tells Wasp which entity to use for storing users.
    userEntity: User,
    methods: {
      // Enable username and password auth.
      usernameAndPassword: {}
    },
    // We'll see how this is used a bit later.
    onAuthFailedRedirectTo: "/login"
  }
}
//By doing this, Wasp will create:
// - Auth UI with login and signup forms.
// - A logout() action.
// - A React hook useAuth().
// - context.user for use in Queries and Actions.





/////LOGIN & SIGNUP PAGES
// FIRST DECLARE
route SignupRoute { path: "/signup", to: SignupPage }
page SignupPage {
  component: import Signup from "@client/SignupPage.jsx"
}

route LoginRoute { path: "/login", to: LoginPage }
page LoginPage {
  component: import Login from "@client/LoginPage.jsx"
}



//// now the react code for the pages
import { Link } from 'react-router-dom'
import { LoginForm } from '@wasp/auth/forms/Login'

const LoginPage = () => {
  return (
    <div style={{ maxWidth: '400px', margin: '0 auto' }}>
      <LoginForm />
      <br />
      <span>
        I don't have an account yet (<Link to="/signup">go to signup</Link>).
      </span>
    </div>
  )
}

export default LoginPage

///////
import { Link } from 'react-router-dom'
import { SignupForm } from '@wasp/auth/forms/Signup'

const SignupPage = () => {
  return (
    <div style={{ maxWidth: '400px', margin: '0 auto' }}>
      <SignupForm />
      <br />
      <span>
        I already have an account (<Link to="/login">go to login</Link>).
      </span>
    </div>
  )
}

export default SignupPage






/////UPDATE MAIN PAGE TO REQUIRE AUTH:
page MainPage {
  authRequired: true,
  component: import Main from "@client/MainPage"
}



//Additionally, when authRequired is true, the page's React component will be provided a user object as prop.
const MainPage = ({ user }) => {
  // Do something with the user
}







///// DEFINING A USER-TASK RELATION
// check primadocs on relations
// ...
entity User {=psl
    id       Int     @id @default(autoincrement())
    username String  @unique
    password String
    tasks    Task[]
psl=}

entity Task {=psl
    id          Int     @id @default(autoincrement())
    description String
    isDone      Boolean @default(false)
    user        User?    @relation(fields: [userId], references: [id])
    userId      Int?
psl=}
// ...


////// UPDATE THE DATABASE!
wasp db migrate-dev



////// UPDATE OPERATIONS TO CHECK AUTHENTICATION
// queries
import HttpError from '@wasp/core/HttpError.js'

export const getTasks = async (args, context) => {
  if (!context.user) {
    throw new HttpError(401)
  }
  return context.entities.Task.findMany({
    where: { user: { id: context.user.id } },
    orderBy: { id: 'asc' },
  })
}

// actions
import HttpError from '@wasp/core/HttpError.js'

export const createTask = async (args, context) => {
  if (!context.user) {
    throw new HttpError(401)
  }
  return context.entities.Task.create({
    data: {
      description: args.description,
      user: { connect: { id: context.user.id } },
    },
  })
}

export const updateTask = async (args, context) => {
  if (!context.user) {
    throw new HttpError(401)
  }
  return context.entities.Task.updateMany({
    where: { id: args.id, user: { id: context.user.id } },
    data: { isDone: args.isDone },
  })
}








///////// LOG OUT BUTTON
//main.page
// ...
import logout from '@wasp/auth/logout'
//...

const MainPage = () => {
  // ...
  return (
    <div>
      // ...
      <button onClick={logout}>Logout</button>
    </div>
  )
}









entity Customer {=psl
    id           Int     @id @default(autoincrement())
    firstName    String  
    lastName     String  
    cityName     String  
    stateName    String  
    zipCode      Int     
    houseNumber  Int     
    streetName   String  
    phoneNumber  String  
    emailAddress String  @unique
    customerNote String
psl=} 










    </script>
  </body>
</html>
